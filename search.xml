<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>秋暮深,醉成一盏海棠色</title>
      <link href="/2025/01/30/%E7%A7%8B%E5%B9%95%E6%B7%B1/"/>
      <url>/2025/01/30/%E7%A7%8B%E5%B9%95%E6%B7%B1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>秋日薄蓉,用菊花煮竹叶青,人与海棠俱醉。————题记 林清玄 </p></blockquote><p>芸芸众生尽数口口声声地说着气味乃是怀旧之际,一种热泪盈眶的信标,引得记忆的荒原上长风一吹,便能够形成燎原之势的导火引线。我窃以为此言非虚。若是诸君不信;还是烦请侧耳细听,有人对自己血脉相连的,西单四牌楼流滿着街头巷尾永远鲜活,永远热烈,永远流动,道听途说的逸闻趣事的胡同里沙甜沙甜的糖炒栗子和热气腾腾,暖洋洋的烤蜜著干燥焦香的郁金色气息纵然是分隔两地,也怀着一种藕丝对它那颗七窍玲珑心依依不舎的情绪。上世纪二,三十年代铁锈色的大二八式自行车震耳欲聋的铃声”叮铃铃”一响即震醒了一整座昏昏欲睡的北平万阙赭石色的紫禁城宫墙,报童嚎亮的吮喝声贩卖着与一笼从纱慢下走漏出有一阵,没一阵扑鼻的咸鲜的小笼包子一道,新鲜出炉的逸闻趣事,在三秋金节,从鸽灰色大衣的防风领无孔不入,又兴致勃勃的空气里,然散作了病入膏育的城市的血脉中以几何指数爆炸,又可引得趋之若莺的黔首黎民心甘情愿地染上的病毒;再观李娟对她血浓于水的阿勒泰莽莽广原,修眉新绿褪得差不多了的天山与阴山脚下枯水期铮涼作响的嫩溪水淡笔为秋高气爽,高到如同-块半透明的琉璃鄰鄰的反光的如洗碧空,青黄不接的草原上一波未平,一波又起的劲风作刀,卷起的牛羊的臍味闻得如痴如醉;当此际,遥远的向日葵地正值盛年金黄色的花盘乃是三足金乌最为忠贞不渝的指南针,执拗地仰起一张张被晒出了些许古铜色,佃强的脸庞乌黑乌黑的瓜子暴露出来,不目不转睛地盯着那颗互古燃烧的火红色恒星的航向,就不会轻而易举地善罢甘休;隐隐约约,走漏着丝丝缕缕难以溢于言表的气味,有一阵,没一阵,吹进了风干的琶房响黑甜的梦境里头;又见余光中执着于高秋的原野上一股好闻的焦味,风华正茂的日头上了三竿显得斗志昂扬,把原野上蚣结的秋草,初晞的宿露,乃至沛然的万象,像一场无人围观的现场吃播里,自顾自地烘烤一块巨制的核桃奶油面包一般,把光阴焙烤得蓬松而又馨香每一个气孔为了酵母的化学反应之故,喜滋滋地发酵,膨胀,直到变成业已吃饱喝足,胖乎乎的模样。颯颯的金风卷起黃熟的银杏叶,赤金色的枫叶,亮密色的梧桐叶,以及枯黄的乌柏木叶,生生将其削作自己批判性的刀笔,擦过斷魂行人的髮边,—许是让他们也作执笔待月之人落墨下一首灵动跳脱的,霜序七绝诗吧？又似是义愤填膺的起义军高高地举起揭竿灭前朝的旗帜,热火朝天,一鼓作气,一马当先,一路艳艳地,从山脚下烧到天尽头。试问,何人见过此等惊才绝艳的张天烈焰呢？可以与当年周郎赤壁借东风,把曹孟德的连环战船烧得个丟盔弃甲溃不成军的场景相媳美。落叶色皮靴踩在橫铺余日的秋山崂嶼的脊骨上,翻起几朵莖金镶玉的丹桂。春风得意马踏长安的蹄铁含香,又可否与娟娟的清芬眷顾过的鞋底作比？不过,最为我所情有独钟的还是非一盞氫盒在林清玄翰墨飘香的笔下,染了秋水不温不火不疾不徐的风骨的散文诗中,暮色打薄,佐以一朵海棠,文火和南山悠然的菊英慢炖的竹叶青婷婷表晏,不绝如线的佘香莫属。黃连味,苦得发紧的流年竟然被一盏林泉荐茶,几蒸几焙,烤出了葳菜继绻的芳香精,被我信手采擷,装入自己腰间的舜华紫色香囊。我挥手掷风月词笔,就此醉倒于陶陶然一盏秋光</p><p>秋到底是从哪个方向,款款地,有韵地走来,虽然未及流风回雪,但是也携着淡云高天。纵观整个蔚为大观的寰宇都无人参透,也是稀松平常。不可否认的是,风霜高洁的西陆真真是一个世间第一等好的时节！以一个压倒性的优势,远远地凌驾于一岁之中,其他三季之上。无他;流水落花的晚春太过伤感,槐阴满庭的鸣蝸多了些喧器,素练飞霜的白藏,又增了些儿寥廓的冷寂,凄寒,伶汀得砸骨,和我的文字别无二致的苍白无力,营养不良。而缓缓的秋容是一种厚重的姿态,凉薄得刚刚好。在露浓花瘦的菊月则最甚。正如我爱不释手的作者林清玄于他鲜为人知的作品&lt;九月很好）娓娓道来的字里行间,笔锋暗转,滑涓细流道出如是的字句一撇一拣,有若用冷冷的擾珞敲冰煮茗的力道：”九月是一个很好的月份,云淡风轻,温和爽颯。。的确,天心的月正圆,皮里春秋膏胰的蟹也正肥,潮头正立,姥曲的藤蔓上垂下一串珠圆玉润成熟的紫晶石,正做好了承筐盈籃的准备。似是让普罗大众忘记了朔风漂漂的冬日的步伐正在渐进性地逼近。不信,你看,纵然是红销翠损的无赖穷秋,刘禹锡亦会另辟蹊径,倒弹琵琶地反拔出一首”自古逢秋悲寂寥,我言秋日胜春朝。”的神来之笔;即使是东风解冻,万紫千红开遍的仲春,不妨柳三变感春悲秋地磋悼着”依旧,依旧,人与绿杨俱瘦。最为我青眼有加的,当属与中秋满月别无二致,半透明的锦霞纱吹弹可破的冰皮月饼的心脏处,吃得心满意足在倾溢的边缘,激爽甘甜的草莓冰 激凌馅儿,实乃是与林清玄《温一壶月光下酒》中,闲雅安恬的清茶素未谋面,相得益彰的忘形神交。草莓果粒羞报的甜冲淡了竹叶青的苦,与此同时心如止水的亮黄绿色茶汤白露天的回甘又解了后信息时代行色匆匆的甜品的腻。这次第,怎一个悠然心会,却不可言传的”妙”字了得！一口冰激凌月饼一口茶,也是一向不适合像《西游记》里,猪八戒吃五关庄里的人参果一样,狼吞虎咽,因而出尽了洋相,而是应该学林海音的骆驼队那样细嚼慢咽。星燃贸迁的变革与规行矩步的礼节交锋上几个回合,碰撞出五光十色的花火,清雅素净的文人风骨共直言快语的千禧年多巴胺盛宴撞在了一起,溶溶烂烂的秋宵月色也情不自禁地动了凡心。被密叶苍青色的锯齿筛得零零散散的金桂是天地的戏台上长袖善舞,义无反顾的芭蕾舞者,谢幕也要打着几个漂亮的旋,轻飘飘地在青瓷白玉的茶盏中点起重重叠叠的涟漪,掠水无痕。殊不知,引得我等饮者左心房的好望角上一场猝不及防,惊涛骇浪的暴风雨,声嘶力竭地淋淋漓滴者,竟然只有我一人而已。</p><p>早晨起来,泡一碗浓茶;往小院四四方方的天井的正中央就这么一坐,听得到青天底下驯鸽带着金属光泽的羽翼’喂喂’地划破天宇的飞声,转而俯首仔仔细细地点数牵牛花架下朝容的蓝朵。牵牛花以蓝紫色为上佳紫色次之,紫红色为最下。  “慧黯的秋风并不善解人意,把我手边一本郁达夫作品集吹成半开的花朵,偏偏又翻到了为人耳熟熱能详的,（故都的秋）的那一页。雪窗萤几身侧,一盏竹叶青凉了又热,热了又凉,与杯中细量日月长的茶叶从满怀被人细嚼慢咽的希望到大失所望又从风雨如晦的失望中重新燃起希望的过程心有灵犀。若是配上小剂量应季风干了的橘柚皮,也未尝不可。”秋色老梧桐。”悲凉萧索的况味在舌尖上打转。鼻翼是情不自禁地扑闪扑闪的蝴蝶翅膀,只恨不能把这般滋味巨细靡邊地呼扇进去。鼻子随着每一次寫动一面郁结,一面舒泰。不如再来上一个马赛尔泛着柠檬皮甜而稳妥的优愁的玛德琳贝壳小蛋糕,一任无微不至的清波包裹着入口即化的每一寸细膩的肌理。妙不可言的普鲁斯特效应刹那间在舌尖层层递进地舒展开来,恍若一朵迟暮的白玉兰花到了半老之年,风韵犹存。同样,未发酵的绿茶从舒展的一刻伊始也不适合梁山好汉狂歌痛饮那样一饮而尽。唯有细细地聆听茶盏里漏漏的水声在你耳边弹响了冷冷七弦,也不知道,奏响的究竟是一曲疏狂豪放的&lt;广陵散）,还是一首性本空山,不适丝竹管弦的俗韵的&lt;鸥鹭忘机）?风过松竹翠柏,茶匙挑却黄蕊色跃然于碗底的一朵芙蓉着秋雨正脉脉不语,方能历历可见。瘦怯怯的荷叶是连波的秋色特地把自己的一身病骨剖开来,撕破了一个洞,沉下心,听跳珠倒溅之声。若是莲花开过一季,落过一季都还带着一痕盈盈的水红色。当此际,我听到自己的心跳和杯中霏罪的淫雨不谋而合;硫禱绊绊,惡窓翠率,有林花谢了春红同人散后,一钩残月天如水那样痒酥酥的感觉,情绪竟然也同此寒秋的雾色一般,连月不开。竹叶青的叶子在烟雨水光澈艳处沉沉浮浮我晦涩难明的心事挑在了叶尖一滴荷脉露上起起落落。一泡苦涩,二泡回甘,三泡香醇,四泡清甜,直到淡泊宁靜的第五泡无异于一杯无色无味的白开水。然则人世潇潇酒酒的南北路上,种种离合悲欢,苦辣辛酸,尽数寓于一盏茶香中。切记,一定要加上一把洛神花,一簇苣楷草,再辅以一丛野生的诗情画意用来调味,可以给自己的心情用一大把式的形容词混合,千万别过了量,导致载的怀古讽今泊泊地冒出来,压沉了曲江池畔的归舟！仿佛郁达夫入木三分的秋毫笔墨滚烫也冰凉的一端,字字索愁断肠的珠现的缽隙里淋过一场瓢泼大雨,清醒的零余者之流的角色,就是为自己量身打造的。每每饮过一盏郁达夫和林清玄的清茶,我的神思都会在文字无瑕的羊脂玉上精雕细琢着一朵一清二白的云。</p><p>“谁此时没有房子,就不必建造;谁此时孤独,就永远孤独。就在一览无余的林荫道上,读书,读书,写一封比旧时的羊肠小径都还要漫长的信,徘徊,落叶纷.飞。….里尔克在其妇霈皆知的得意之作么秋日）里曾如是说道。一盏竹叶青泡到了最能得意忘言的最后一泡。转念一想,自己熟视无睹的,郁达夫沉郁顿挫的都的秋入,又何尝不是离人心上织出双丝网,结成的一拆孤独的秋？我一向都是以出离于世态人情,不问世事之人自翊,也甚喜闲登小阁,只有此般,才得以极目阅尽跨坐在墙头陌上,人间凉薄又清醒,绚烂又寂寬的秋色。相较于梨云杏雨可爱的春日,我永远偏爱自筋自饮,自醉其中的桐秋。又偏偏贪了徘徊在小园的香径上的闲情逸致,帆布包的夹层带上一本速写本,草草地描墓下丛菊两开他日泪,孤舟一系故园心,也描墓下雨打归舟泪万行孤鴻远影。密密麻麻地卷云纹乃是王義之奔放酒脱的行草,抑或是李义山的七律,杜牧的七绝。我除放开手,一任它羽化飞去以外,别无他法。原来秋日的况味也有万千般,有的往昔不复有的如初,而我品到的是铭心刻我被茶壶底暮秋籍籍无名的草木判处了一种与世隔绝的香茗刑,而裁决者,正好以纷纷扰扰的浮世里难得的清欢,作为其懿名佳姓。</p>]]></content>
      
      
      <categories>
          
          <category> 心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随机数</title>
      <link href="/2025/01/29/%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
      <url>/2025/01/29/%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="随机数浅谈"><a href="#随机数浅谈" class="headerlink" title="随机数浅谈"></a>随机数浅谈</h1><h2 id="一个游戏"><a href="#一个游戏" class="headerlink" title="一个游戏"></a>一个游戏</h2><p>我与你做一个游戏，你需要从1-10中选一个数，让我来猜你选的是数字几。猜对给你给我三个硬币，猜错我给你一个硬币。怎么样？</p><p>开始游戏无论你猜几，我都猜数字7，肯定有不少人嘲笑我猜错了，但是我只要不断和没有玩过这个游戏的人玩这个游戏，我就能稳赚不赔。你可能会疑惑为什么，其实很简答。因为你选的数字并不是等概率随机的。比如你在看视频时多数时间并不会对各种logo反感，因为这些logo往往位于角落里。虽然眼睛无差别的接受到这些信号。但是我们的感知却不大，说明我们的注意力遭到了某些因素影响，对于刚才的游戏来说，也有一些你想不到的因素在影像你做出选择，比如对于1-10这10个数字，1,10,2,9在开头和结尾，会让你觉得选他们不算“随机”，数字4,6,8对于中国人又有特殊意义，让你觉得选他们也不“随机”剩下的数字3,5,7中，3又太小，5位于中间，让你觉得选他们也“不随机”。所以你选数字7。这个解释很多人会觉得过于牵强，没错，这是我编的。</p><p>我之所以选择是数字7，因为在一项8600人的调查中，28%的人选择的数字7，明显超过选择其他数字的人，所以，虽然大多数情况下我都猜错，但是只要涉及一个看似对你有利的游戏规则。我就能源源不断的赢取硬币。再看调查的人，如果他们真正的是随机选的数字，那么每个数字选的概率应该比较平均才对，所以肯定有一些因素影响了我们的大脑，不让我们等概率选出一个随机数。</p><h2 id="到底什么才是随机数"><a href="#到底什么才是随机数" class="headerlink" title="到底什么才是随机数"></a>到底什么才是随机数</h2><p>如果刚才你选了数字8,那么8是一个随机数吗？如果是，那如果后一个人也选了8，在后面一个人也选了数字8，那么8还是随机数吗？所以对于一个数字来说，不能用随机来描述。随机是针对一组序列而言。</p><h2 id="随机数有什么用？"><a href="#随机数有什么用？" class="headerlink" title="随机数有什么用？"></a>随机数有什么用？</h2><p>首先说明一个结论：就像我们的大脑一样。人类要想获得一个真正的随机数并不是一件容易的事。</p><p>随机数最简单的应用就是赌博和彩票开奖，当你掷出一个骰子，转动一个轮盘，加入你没有作弊的话，得到的结果肯定是随机的。</p><p>在工程中，随机数也有更为重要的作用，例如：在海洋工程建设中就需要计算机对海浪惊醒模拟，一种方法就是使用海浪谱，海浪谱是根据海浪测量数据拟合得到的理想数学描述方式，但是海浪是个随机过程，为了减少误差，模拟出更真实的海浪，就需要随机数产生的相位角叠加到理想的海浪谱上，得到这样的随机数不能靠掷骰子，转轮盘得到，需要使用计算机，当你使用计算机随机数命令，计算机回产生一系列的随机数，那么这些数是随机的吗？计算机都是按照一定指令执行的，以python为例，它使用一种名为马特赛特选择算法来产生随机数，但无论是什么算法，都需要设置一个初始值，也就是种子，算法根据种子计算输出结果，这种算法生成的随机数称为伪随机数，既然随机序列是通过种子计算得到的那么只要种子相同，生成的序列也就相同，所以问题就成了有没有算法能生成随机的种子？</p><p>额，问题又绕了开始，实际上算法确实没有办法生成随机的种子，只要重复足够多总能找的规律可使用一些方法进行检验，比如蒙特卡洛法，一个因制造原子弹而发明，有以赌城命名的算法注定充满了数学的优美和工业的暴力，这种方法思路简单，在正方形内作出一个内切圆，将随机生成的数字转换为坐标中的点，当生成足够多后，统计圆内点数和总点数，如果比值接近$π/4$，则一般认为这些数随机，如果要求不高，还可以尝试把生成的随机数填充为图片，就很容易观察到它是否产生了规律，但是蒙特卡洛算法并不能证明序列是否正随机，一些经过设计的序列也能通过检测，但通常如果能通过统计检验，我们一般把它当做随机数使用</p><h2 id="伪随机数"><a href="#伪随机数" class="headerlink" title="伪随机数"></a>伪随机数</h2><p>伪随机数容易被检测到，预测周期和下一个数，但是如果一个伪随机序列的周期非常长，从宇宙诞生到现在就没有重复过，效果会怎样呢？</p><p>前面说过蒙特卡洛算法的重复周期长达$2^{19937-1}$，这个数字比现在观测到的宇宙原子总数还多，算法周期足够长。事实上，生活中都在使用算法生成的伪随机数，不过安全最总还是归为算力的多少，假若有一天算力无穷大。伪随机数就毫无安全可言了。2014年，一群俄罗斯人在破解了角子机的奥秘后，在美国赌场大赚一笔，最后被FBI一网打尽。他们就是发现赌场的角子机是使用一时间为种子生成伪随机数。</p><h2 id="真随机数"><a href="#真随机数" class="headerlink" title="真随机数"></a>真随机数</h2><p>伪随机数方便，但就不能使用正随机的=数吗。获得正随机数，还得回归物理世界，获得正随机数，有没有比掷骰子更快的方法？$铯^{137}$这种半衰期为30.17年的放射性同位素，无时无刻不在释放$\beta$离子，使用盖革计数器测量这些离子，当高能$\beta$离子穿透盖革管时，能使内部气体电离导电，计数器就会发出一个脉冲电流信号，并发出轻微的卡卡声，而$铯^{137}$释放$\beta$粒子的时间是随机的，可以通过比较两个脉冲信号的时间间隔，就能生成连续的正随机数。1947年，美国兰德公司使用类似的方法，花费两个月的时间，生成了1000000位随机数，并出版成一本书出售，售价84.19美元</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从技术层面来说，随机数正的不容易获得，其次在不规则的咔咔声中有人类一致无法解释的秘密。我们无法预测下一秒哪一个铯原子会发生衰变，但是我们却明确知道在30.17年之后，会有一半的$Se^{137}$会发生衰变成为$Ba^{137}$，而随机的原理至今人类也无从知晓，取名为“测不准原理”。而这背后是拉普拉斯妖和自由意志的对决，宇宙中所有的一切都是注定的吗？如果我知道开奖当天所有的数据，我能猜到开奖的号码吗？我们每个人的命运生来就是注定的吗，躺平和苦干结果会一样吗？</p>]]></content>
      
      
      <categories>
          
          <category> 天文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 探索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光从太阳到地球竟然需要500万年</title>
      <link href="/2025/01/28/%E5%B8%83%E6%9C%97%E8%BF%90%E5%8A%A8/"/>
      <url>/2025/01/28/%E5%B8%83%E6%9C%97%E8%BF%90%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="布朗运动"><a href="#布朗运动" class="headerlink" title="布朗运动"></a>布朗运动</h1><p>太阳发出的光需要多久才能到达地球？</p><h2 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h2><p>英国植物学家布朗，发现花粉在水中游动，猜测原因：</p><ol><li>花粉有生命 ———&gt; 将花粉炒熟，</li><li>外界干扰（气流，水的蒸发……）————&gt; 实验控制外界干扰，</li><li>水中有微生物 ———&gt; 将花粉换做镁粉，使用酒精，煤油</li></ol><p>布朗做了实验了以上方法后，发现，花粉任然会运动。出现原子解释。</p><ol><li>水分子的无规则运动</li><li>撞击花粉不均匀</li><li>温度高，布朗运动剧烈</li></ol><h2 id="爱因斯坦证明原子存在"><a href="#爱因斯坦证明原子存在" class="headerlink" title="爱因斯坦证明原子存在"></a>爱因斯坦证明原子存在</h2><h3 id="无规则行走问题"><a href="#无规则行走问题" class="headerlink" title="无规则行走问题"></a>无规则行走问题</h3><p>如果把时间离散化为步长$\Delta t$的小段,令 $t = n\Delta t$,同时保持$\Delta t$适当大,使得每小段时间头尾 的运动彼此无关,于是行走$n$步的结果$x_n$就是n个 独立随机变量之和.自然,</p><script type="math/tex; mode=display">< x_n > = 0,< x_n^2 > \Rightarrow n</script><p>可见,均方距离并不是正比于步数n,</p><script type="math/tex; mode=display">\begin{matrix}1 & x & x^2 \\1 & y & y^2 \\1 & z & z^2 \\\end{matrix}</script><p>步长 $|\vec{x_i}| = L$ </p><p>距离 <script type="math/tex">R_N =\sum_{i=1}^N \vec{x_i}</script></p><h3 id="花粉位置随时间变化的规律"><a href="#花粉位置随时间变化的规律" class="headerlink" title="花粉位置随时间变化的规律"></a>花粉位置随时间变化的规律</h3><ol><li>假设花粉每走一步$|a_n|=1$，方向随机</li><li>求N步之后$&lt;|S_n|&gt; = ?$</li></ol><p>怎么q求$S_n$呢？</p><p> <img src="https://cdn.jsdelivr.net/gh/beforelike/picx-images-hosting@master/向量法_布朗运动.1vyr8r7cnx.jpg" alt="向量法"></p><p>如果：</p><ol><li>$n=1 ,S_1 = a_1 = 1$</li><li>$\vec S<em>n = \vec S</em>{n-1} +\vec a_n$</li></ol><p>所以：</p><p>$S<em>n^2 = S</em>{n-1}^2 + a<em>n^2+2\vec S</em>{n-1} . \vec a<em>n$ 因为 $2\vec S</em>{n-1}$和$\vec a_n$方向随机，平均值等于0。</p><p><script type="math/tex">< S_n^2 > = < S_{n-1}^2 > + < a_n^2 ></script>，$an$为步长，</p><p>$&lt;|S_n|&gt; = \sqrt x a_n$</p><h2 id="太阳光"><a href="#太阳光" class="headerlink" title="太阳光"></a>太阳光</h2><p>所以我们需要知道分子的平均速度$v$，扩散时间$t$,平均自由程$L$也就是$a_n$。就是每次不转向所走长度。</p><p>每步$t_0 = \frac{L}{v}$，步数$N=\frac{t}{t_0}=\frac{vt}{L}$，$&lt; S_n &gt; = \sqrt{vtL}$</p><p>太阳光：</p><p>假设光需要从太阳中心开始扩散，扩散距离为太阳半径。$R = 7×10^8m，v = 3×10^8m,L=10^{-5}m$</p><p>得出光从太阳中心扩散到表面的距离是$t = \frac{R_N^2}{vL} =5000000年$</p>]]></content>
      
      
      <categories>
          
          <category> 天文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 探索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于AIDS</title>
      <link href="/2025/01/23/%E5%85%B3%E4%BA%8EAIDS/"/>
      <url>/2025/01/23/%E5%85%B3%E4%BA%8EAIDS/</url>
      
        <content type="html"><![CDATA[<h1 id="纸条话题——艾滋病是社会-医学问题"><a href="#纸条话题——艾滋病是社会-医学问题" class="headerlink" title="纸条话题——艾滋病是社会/医学问题"></a>纸条话题——艾滋病是社会/医学问题</h1><p>生命不是政权的牺牲品。真确的认识才是保护自己的最好方式。</p><p>艾滋病是一种免疫缺陷病，患者最终会死于其他疾病。这是我听到关于艾滋病的描述。每个人都这么说；</p><p>每个人都觉得艾滋病传播到社会上是因为医学不先进。</p><p>艾滋病病毒接触到就会被感染，没有办法缓解，医治。我从未听到过关于艾滋病的其他描述。我对艾滋的印象也是各种宣传图画中去了色彩显露恐怖的艾滋病患者。曾几何时，我也莫名害怕过艾滋病，但稍稍想想，不过是杞人忧天的自我焦虑的表现。我没见过艾滋病患者，也不了解艾滋病人。我其实根本就不惧怕艾滋病，准确的说我就没有辨别艾滋病的任何一种能力。我早就被各种舆论埋没了我的认知。甚至，一致认为这是个医学难题。今天，我又看到这个话题。我反而是对于申明有了一种敬畏，艾滋病并不是不无药可医，现在世界上有240多种抗逆转录药可以治疗这种病，并且85%以上的人都会重建免疫系统，但也有一点坏消息：一些患者服用药物后并没有重建免疫系统，重建免疫系统后也需要终生用药。瑞士提过艾滋病患者康复后可以停药，正常生育。但是没有被接受。但能治愈患者，绝对比随意宣传更能让人感到三东暖。E而且在高危环境中怀疑自己接触到了病毒，应该在24之内遵医嘱服用阻断药物，服用二十八天，能完全阻断艾滋病毒的传播。防止自己感染艾滋病毒。只要你想，天无绝人之路，广袤的土地，多活你一个也不会多。</p><p>医学有这么高的医疗水平，药物研发也不少。为什么我们总是只能听到危机四伏，却听不到一点点对抗危机的方法？其实艾滋病从传播到人类社会那一刻开始，就不想管这个病毒。全世界范围内传播的艾滋病病毒是HIV-1的M型病毒。当时美国发现这种病毒，没有将研究这种病毒的危害，传播途径，传播范围。偌大的政府面对责任。反手寻找“零号病人”——杜加，一位男同性恋者，把责任推卸给他后，就没有下文了。柳叶刀杂志主编说找零号病人对于现代医学没有任何用。nature杂志也说，杜加在切除肉瘤后，还保持混乱的性生活。但绝对不是他将病毒从非洲带到美洲吗，更不是零号病人。艾滋病病毒起源于非洲刚果、喀麦隆。可能由于私人采血商的不规范操作。美国地区血友病患者会输血商的血造成艾滋病传播到纽约地区。在初期，也是美国旧金山同性恋聚会后，医院发现有些患者体内辅助性T细胞数量几乎为0，肿瘤加速恶化。医院认为是一种同性恋疾病。后来医院接诊了更多的相似患者，就由于里根政府为了节省预算，媒体不感兴趣，就没有对这种病毒进行研究。只有医院一线工作人员会研究。刚开始认为只会在男同性恋之间，通过精液或唾液传播。到后面，发现一位有静脉注射吸毒史的女性患者，医院认为血液可以传播这种病毒。而当时血库中有大量血来自同性恋人群（因为他们认为他们的后代更有民族意识），但是这触碰了当权者的利益，血库的血液全部检测一遍，无疑又会增加开支。后面电视台开始报道这场疫情，政府都没有画出经费用于研究这种病毒。直到一位巴黎医生对淋巴切片研究，才证明血液里有艾滋病毒。但是当时病毒爆发两年，很多新生儿都输了受感染的血液。后来发现艾滋病不仅在男同型恋之间传播，异性之间也能传播，任何人都可能感染，这马上引来了血库，血控中心的质疑，一些官员甚至说不存在艾滋病，不用筛查血液，浪费成本，到1983年美国疾控中心显示感染艾滋病1458人，死亡人数500多人。人数不多。取让医院发现另外一个问题，艾滋病潜伏期很长，很多病毒携带者正在把病毒传递给跟多的人，当时里根什么都没有做，在自传中说艾滋病是上帝对同性恋患者的惩罚。对患者和医院的求助视而不见。直到好莱坞明星赫德森死于艾滋病。这时里根政府才被迫发表“获得性免疫缺陷综合征”的疫情公开演讲时，美国已经有至少六万人感染艾滋，死亡三万人。随后在艾滋病病毒方面的经费预算就成了美国的传统直到现在。</p><p>人类总是在承担责任时才意识到后果严重，爱他人，也先爱自己。</p>]]></content>
      
      
      <categories>
          
          <category> 心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习的hello world</title>
      <link href="/2025/01/23/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84hello%20world/"/>
      <url>/2025/01/23/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84hello%20world/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习和深度学习"><a href="#机器学习和深度学习" class="headerlink" title="机器学习和深度学习"></a>机器学习和深度学习</h1><h2 id="人工智能，机器学习，-深度学习"><a href="#人工智能，机器学习，-深度学习" class="headerlink" title="人工智能，机器学习， 深度学习"></a>人工智能，机器学习， 深度学习</h2><p>人工智能 &gt; 机器学习 &gt; 深度学习</p><p>人工智能artificial intelligence 是一门学科，这个定义只是阐述了目标，没有方法，产生的分支较多，机器学习是当前实现人工智能的一种方式，深度学习是机器学习的一项分支。在近年已经替代大多数机器学习算法。</p><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>区别于人工智能，机器学习，尤其是监督学习则更有指代。机器学习是指如何让计算机模拟或实现人类的学习行为，以获得新的知识，重组已有的知识结构，使之不断完善自身结构性能</p><h4 id="机器学习实现原理"><a href="#机器学习实现原理" class="headerlink" title="机器学习实现原理"></a>机器学习实现原理</h4><p>归纳为两步：训练和预测，类似于归纳与演绎</p><p><strong>归纳</strong>  ：从具体事件中抽象出一般规律</p><p><strong>演绎</strong>  ：从一般规律推导出具体案例的结果</p><h4 id="机器学习实施方法"><a href="#机器学习实施方法" class="headerlink" title="机器学习实施方法"></a>机器学习实施方法</h4><p>实施机器学习和人类科研类似，机器学习（监督学习）方法论本质，即在“机器思考”过程中确定模型的三要素：假设，评价，优化</p><ol><li>机器从牛顿第二定律中学习知识</li></ol><p>牛顿第二定律是艾萨克·牛顿在1687年《自然哲学的数学原理》一书中提出，常见表述为：<strong>物体的加速度跟作用力成正比，跟物体的质量成反比</strong>  </p><h1 id="波士顿房价预测"><a href="#波士顿房价预测" class="headerlink" title="波士顿房价预测"></a>波士顿房价预测</h1><p>波士顿房价预测是一个经典的机器学习任务，类似与程序员的“hello world”。和大家的普遍认知相同，波士顿地区的房价受多方面影响，学习的数据集提供13个影响房价的因素，期望构建一个基于13个因素进行房价预测。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42731236/1734779855271-59a7c4e1-f2e0-4b1c-96d7-36974a44bf52.png" alt="波士顿房价影像示意图"></p><p>对于简单的预测问题，可以预测输出的类型是连续的实数值，还是离散的标签，区分为回归任务和分类任务因为房价是一个连续值，所以房价预测是一个回归任务，使用线性回归模型解决这个问题，利用神经网络实现这个模型。</p><blockquote><ol><li><strong><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">回归任务</font></strong><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">：目标变量（预测值）是连续的数值。例如，预测股票价格、气温变化或房屋价格等。在回归任务中，机器学习模型会尝试找到一个函数，该函数能够将输入特征映射到连续的目标值上。</font></li><li><strong><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">分类任务</font></strong><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">：目标变量是离散的类别标签。例如，预测邮件是否为垃圾邮件、图像中的对象是什么类别或患者是否患有某种疾病等。在分类任务中，模型会学习如何根据输入特征将样本划分到不同的类别中</font></li></ol></blockquote><h2 id="线性回归模型"><a href="#线性回归模型" class="headerlink" title="线性回归模型"></a>线性回归模型</h2><p>假设房价和各个影像因素之间能够用线性关系来描述</p><p>$ y = \sum_{j=1}^{m} c_j w_j + b $</p><p>模型的求解即是通过数拟合除每个$ w_j $和b。其中$ w_j $和b 分贝表示该线性模型的权重和偏执。一维情况下，$ w_j $是斜率，b 是截距</p><p>线性回归模型使用均方误差为（mean squared error）损失函数（Loss），用于衡量预测房价和真实房价之间的差异。</p><p>$ MSE = \frac{1}{N} \sum_{i=1}^{N} (\hat{Y}_i - Y_i)^2 $</p><blockquote><p>为什么要以均方误差作为损失函数？即模型在每个训练样本的预测误差加和，来衡量整体样本的准确性。</p><p>因为损失函数的设计不仅仅考虑合理性（有物理意义），还需要考虑“易解性”（易于求解）。</p></blockquote><h2 id="线性回归模型的神经网络结构"><a href="#线性回归模型的神经网络结构" class="headerlink" title="线性回归模型的神经网络结构"></a>线性回归模型的神经网络结构</h2><p>神经网络的标准结构中每个神经元由加权和非线性变换构成，然后将多个神经元分层的摆放并连接形成神经网络。线性回归模型可以认为是神经网络模型最简单的一种特例，是一种没有加权和，没有非线性变换的神经元（无需形成网络）</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42731236/1734782837910-3c1c9ddf-30bb-4bd5-8e9e-93548f0c46d3.png" alt="线性回归模型的神经网络结构"></p><h2 id="基于线性回归实现波士顿房价预测任务"><a href="#基于线性回归实现波士顿房价预测任务" class="headerlink" title="基于线性回归实现波士顿房价预测任务"></a>基于线性回归实现波士顿房价预测任务</h2><p>深度学习不仅实现模型的端到端学习，还推动人工智能进入工业生产大阶段，产生了标准化、自动化和模块化的通用框架。不同场景下的深度模型具备一定的通用性，五个步骤即可完成模型的构建和训练，<img src="https://cdn.nlark.com/yuque/0/2024/png/42731236/1734783132030-a8cad725-73f7-46db-9773-baee04139bbd.png" alt="构建神经网络/深度学习的基本步骤"></p><p>由于深度学习的建模和训练过程具有一定的通用性，即在构建不同的模型时，只要三要素不同，其他步骤基本一致，才产生了深度学习框架来加速建模</p><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><p>数据处理分为五个部分：数据导入、数据形状的变换、数据集的划分、数据归一划处理和封封装<code>load data</code>函数。数据预处理后才能被模型调用。</p><ol><li>数据读取</li></ol><p>通过一下代码读入数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入需要用到的package</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># 读入训练数据</span></span><br><span class="line">datafile = <span class="string">&#x27;./work/housing.data&#x27;</span></span><br><span class="line">data = np.fromfile(datafile, sep=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">data</span><br></pre></td></tr></table></figure><ol><li>数据结构转换</li></ol><p>由于读入的数据是一位的，所有的数据都是连在一起的，因此我们需要将数据进行形状转换，形成一个二维的矩阵，每行为一份数据样本（14个值）。每个数据集包含13个$ x $影响房价的特征和一个$ y $该房屋的均价</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读入之后的数据被转化成1维array，其中array的第0-13项是第一条数据，第14-27项是第二条数据，以此类推.... </span></span><br><span class="line"><span class="comment"># 这里对原始数据做reshape，变成N x 14的形式</span></span><br><span class="line">feature_names = [ <span class="string">&#x27;CRIM&#x27;</span>, <span class="string">&#x27;ZN&#x27;</span>, <span class="string">&#x27;INDUS&#x27;</span>, <span class="string">&#x27;CHAS&#x27;</span>, <span class="string">&#x27;NOX&#x27;</span>, <span class="string">&#x27;RM&#x27;</span>, <span class="string">&#x27;AGE&#x27;</span>,<span class="string">&#x27;DIS&#x27;</span>, </span><br><span class="line">                 <span class="string">&#x27;RAD&#x27;</span>, <span class="string">&#x27;TAX&#x27;</span>, <span class="string">&#x27;PTRATIO&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;LSTAT&#x27;</span>, <span class="string">&#x27;MEDV&#x27;</span> ]</span><br><span class="line">feature_num = <span class="built_in">len</span>(feature_names)</span><br><span class="line">data = data.reshape([data.shape[<span class="number">0</span>] // feature_num, feature_num])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">x = data[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(x.shape)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><ol><li>数据集的划分</li></ol><p>将数据集划分为训练集和测试集，其中训练集用于确定模型参数，测试集用于评判模型的效果，</p><blockquote><p>为什么要对数据集进行划分，而不直接用于模型训练？</p><p><font style="color:rgb(102, 102, 102);">这与学生时代的授课和考试关系比较类似，如</font><br> <img src="https://cdn.nlark.com/yuque/0/2024/png/42731236/1734784293095-d74cb542-c1aa-4e15-b2e8-0c7bcfd3edfa.png" alt="测试集和训练集的意义"></p></blockquote><p>我们期望模型学习的是任务的本质规律，而不是数据本身，模型训练未使用的数据，才能更真实的评估模型的效果</p><p>学习过程中的数据集80%用作训练，20%用作测试，每个样本包含13个特征和1个预测值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ratio = <span class="number">0.8</span></span><br><span class="line">offset = <span class="built_in">int</span>(data.shape[<span class="number">0</span>] * ratio)</span><br><span class="line">training_data = data[:offset]</span><br><span class="line">training_data.shape</span><br></pre></td></tr></table></figure><ol><li>数据的归一化处理</li></ol><p>对每个数据进行归一化处理，4每个特征的取值都缩放到0~1之间，这样做有两个好处：一是模型训练跟高效；二是特征前的权重大小可以表示变量对预测结果的贡献度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">maximums, minimums = \</span><br><span class="line">                     training_data.<span class="built_in">max</span>(axis=<span class="number">0</span>), \</span><br><span class="line">                     training_data.<span class="built_in">min</span>(axis=<span class="number">0</span>), </span><br><span class="line"><span class="comment"># 对数据进行归一化处理</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(feature_num):</span><br><span class="line">    data[:, i] = (data[:, i] - minimums[i]) / (maximums[i] - minimums[i])</span><br></pre></td></tr></table></figure><ol><li>分装成load data函数</li></ol><p>将上面的数据操作封装成oad data函数，方便调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_data</span>():</span><br><span class="line">    <span class="comment"># 从文件导入数据</span></span><br><span class="line">    datafile = <span class="string">&#x27;./work/housing.data&#x27;</span></span><br><span class="line">    data = np.fromfile(datafile, sep=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每条数据包括14项，其中前面13项是影响因素，第14项是相应的房屋价格中位数</span></span><br><span class="line">    feature_names = [ <span class="string">&#x27;CRIM&#x27;</span>, <span class="string">&#x27;ZN&#x27;</span>, <span class="string">&#x27;INDUS&#x27;</span>, <span class="string">&#x27;CHAS&#x27;</span>, <span class="string">&#x27;NOX&#x27;</span>, <span class="string">&#x27;RM&#x27;</span>, <span class="string">&#x27;AGE&#x27;</span>, \</span><br><span class="line">                      <span class="string">&#x27;DIS&#x27;</span>, <span class="string">&#x27;RAD&#x27;</span>, <span class="string">&#x27;TAX&#x27;</span>, <span class="string">&#x27;PTRATIO&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;LSTAT&#x27;</span>, <span class="string">&#x27;MEDV&#x27;</span> ]</span><br><span class="line">    feature_num = <span class="built_in">len</span>(feature_names)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将原始数据进行Reshape，变成[N, 14]这样的形状</span></span><br><span class="line">    data = data.reshape([data.shape[<span class="number">0</span>] // feature_num, feature_num])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将原数据集拆分成训练集和测试集</span></span><br><span class="line">    <span class="comment"># 这里使用80%的数据做训练，20%的数据做测试</span></span><br><span class="line">    <span class="comment"># 测试集和训练集必须是没有交集的</span></span><br><span class="line">    ratio = <span class="number">0.8</span></span><br><span class="line">    offset = <span class="built_in">int</span>(data.shape[<span class="number">0</span>] * ratio)</span><br><span class="line">    training_data = data[:offset]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算训练集的最大值，最小值</span></span><br><span class="line">    maximums, minimums = training_data.<span class="built_in">max</span>(axis=<span class="number">0</span>), \</span><br><span class="line">                            training_data.<span class="built_in">min</span>(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对数据进行归一化处理</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(feature_num):</span><br><span class="line">        data[:, i] = (data[:, i] - minimums[i]) / (maximums[i] - minimums[i])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练集和测试集的划分比例</span></span><br><span class="line">    training_data = data[:offset]</span><br><span class="line">    test_data = data[offset:]</span><br><span class="line">    <span class="keyword">return</span> training_data, test_data</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">training_data, test_data = load_data()</span><br><span class="line">x = training_data[:, :-<span class="number">1</span>]</span><br><span class="line">y = training_data[:, -<span class="number">1</span>:]</span><br></pre></td></tr></table></figure><h3 id="模型设计"><a href="#模型设计" class="headerlink" title="模型设计"></a>模型设计</h3><p>模型设计是深度学习模型的关键要素之一，也成为网络结构设计，相当于模型假设空间，即实现模型“前向计算”（从模型输入到输出）的过程。</p><p>如果将输入特征和输出预测值均以向量表示，输入特征$ x $有13个向量，$ y $有1个向量，那么参数的权重为的形状为13 ×1.假设我们以下任意数字赋值参数化做初始值：</p><p>$ w=[0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,−0.1,−0.2,−0.3,−0.4,0.0] $</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = [<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.4</span>, <span class="number">0.5</span>, <span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, -<span class="number">0.1</span>, -<span class="number">0.2</span>, -<span class="number">0.3</span>, -<span class="number">0.4</span>, <span class="number">0.0</span>]</span><br><span class="line">w = np.array(w).reshape([<span class="number">13</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>取出条样本数据，观察样本向量与参数向量相乘的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x1=x[<span class="number">0</span>]</span><br><span class="line">t = np.dot(x1, w)</span><br><span class="line"><span class="built_in">print</span>(t)</span><br></pre></td></tr></table></figure><pre><code>    完整的线性回归公式，还需要初始化偏移量$ b $,同样随意赋初始值-0.2 。那么线性回归模型的完整输出是$ z = t + b $,这个特征和参数计算输出值得过程称为“前向计算”。</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = -<span class="number">0.2</span></span><br><span class="line">z = t + b</span><br></pre></td></tr></table></figure><p>将上述计算预测输出的过程类似“类与对象”的方式来描述，类成员变量参数$ w $和$ b $,通过写一个<code>forward</code>函数（代表前向计算）完成上述从特征和参数输出预测值的计算过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Network</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_of_weights</span>):</span><br><span class="line">        <span class="comment"># 随机产生w的初始值</span></span><br><span class="line">        <span class="comment"># 为了保持程序每次运行结果的一致性，</span></span><br><span class="line">        <span class="comment"># 此处设置固定的随机数种子</span></span><br><span class="line">        np.random.seed(<span class="number">0</span>)</span><br><span class="line">        <span class="variable language_">self</span>.w = np.random.randn(num_of_weights, <span class="number">1</span>)</span><br><span class="line">        <span class="variable language_">self</span>.b = <span class="number">0.</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        z = np.dot(x, <span class="variable language_">self</span>.w) + <span class="variable language_">self</span>.b</span><br><span class="line">        <span class="keyword">return</span> z</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>基于Network类的定义，模型计算过程如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">net = Network(<span class="number">13</span>)</span><br><span class="line">x1 = x[<span class="number">0</span>]</span><br><span class="line">y1 = y[<span class="number">0</span>]</span><br><span class="line">z = net.forward(x1)</span><br><span class="line"><span class="built_in">print</span>(z)</span><br></pre></td></tr></table></figure><h3 id="训练配置"><a href="#训练配置" class="headerlink" title="训练配置"></a>训练配置</h3><p>模型设计完成后，需要训练配置寻找最优值，即通损失函数来衡量模型的好坏，训练配置也是深度学习模型的关键要素之一。</p><p>通过模型计算$ x_1 $表示的影响因素所对应的房价应是$ z $,但实际数据告诉我们房价是$ y $。于是我们需要有某种指标来衡预测值$ z $跟真实值$ y $之间的差距。对于回归问题最常采用的衡量方法是使用均方差作为评价模型好坏的指标，公式为$ Loss = (y-z)^2 $</p><p>上述式的$ Loss $通常被称为损失函数，他是衡量模型好坏的指标，在回归问题中常用均方程作为损失函数，而在分类问题中常采用交叉熵（Cross-Entropy）作为损失函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Loss = (y1 - z) ** <span class="number">2</span></span><br></pre></td></tr></table></figure><font style="color:rgb(102, 102, 102);">因为计算损失函数时需要把每个样本的损失函数值都考虑到，所以我们需要对单个样本的损失函数进行求和，并除以样本总数</font><font style="color:rgb(102, 102, 102);">N</font>_<font style="color:rgb(102, 102, 102);">N</font>_<font style="color:rgb(102, 102, 102);">。公式为</font><p>$ Loss = \frac{1}{N} \sum_{i=1}^{N}(Y_i - \hat{Y}_i)^2 $</p><font style="color:rgb(102, 102, 102);">在Network类下面添加损失函数的代码实现如下：</font><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Network</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_of_weights</span>):</span><br><span class="line">        <span class="comment"># 随机产生w的初始值</span></span><br><span class="line">        <span class="comment"># 为了保持程序每次运行结果的一致性，此处设置固定的随机数种子</span></span><br><span class="line">        np.random.seed(<span class="number">0</span>)</span><br><span class="line">        <span class="variable language_">self</span>.w = np.random.randn(num_of_weights, <span class="number">1</span>)</span><br><span class="line">        <span class="variable language_">self</span>.b = <span class="number">0.</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        z = np.dot(x, <span class="variable language_">self</span>.w) + <span class="variable language_">self</span>.b</span><br><span class="line">        <span class="keyword">return</span> z</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">loss</span>(<span class="params">self, z, y</span>):</span><br><span class="line">        error = z - y</span><br><span class="line">        cost = error * error</span><br><span class="line">        cost = np.mean(cost)</span><br><span class="line">        <span class="keyword">return</span> cost</span><br></pre></td></tr></table></figure><font style="color:rgb(102, 102, 102);">使用定义的Network类，可以方便的计算预测值和损失函数。需要注意的是，类中的变量</font><font style="color:rgb(102, 102, 102);">x</font>**<font style="color:rgb(102, 102, 102);">x</font>**<font style="color:rgb(102, 102, 102);">,</font><font style="color:rgb(102, 102, 102);"> </font><font style="color:rgb(102, 102, 102);">w</font>_<font style="color:rgb(102, 102, 102);">w</font>_<font style="color:rgb(102, 102, 102);">，</font><font style="color:rgb(102, 102, 102);">b</font>_<font style="color:rgb(102, 102, 102);">b</font>_<font style="color:rgb(102, 102, 102);">,</font><font style="color:rgb(102, 102, 102);"> </font><font style="color:rgb(102, 102, 102);">z</font>_<font style="color:rgb(102, 102, 102);">z</font>_<font style="color:rgb(102, 102, 102);">,</font><font style="color:rgb(102, 102, 102);"> </font><font style="color:rgb(102, 102, 102);">e</font><font style="color:rgb(102, 102, 102);">r</font><font style="color:rgb(102, 102, 102);">r</font><font style="color:rgb(102, 102, 102);">o</font><font style="color:rgb(102, 102, 102);">r</font>_<font style="color:rgb(102, 102, 102);">e</font>__<font style="color:rgb(102, 102, 102);">r</font>__<font style="color:rgb(102, 102, 102);">r</font>__<font style="color:rgb(102, 102, 102);">o</font>__<font style="color:rgb(102, 102, 102);">r</font>_<font style="color:rgb(102, 102, 102);">等均是向量。以变量</font><font style="color:rgb(102, 102, 102);">x</font>**<font style="color:rgb(102, 102, 102);">x</font>**<font style="color:rgb(102, 102, 102);">为例，共有两个维度，一个代表特征数量（值为13），一个代表样本数量，代码如下所示。</font><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">net = Network(<span class="number">13</span>)</span><br><span class="line"><span class="comment"># 此处可以一次性计算多个样本的预测值和损失函数</span></span><br><span class="line">x1 = x[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">y1 = y[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">z = net.forward(x1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;predict: &#x27;</span>, z)</span><br><span class="line">loss = net.loss(z, y1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;loss:&#x27;</span>, loss)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习之numpy</title>
      <link href="/2025/01/23/%E5%85%B3%E4%BA%8Enumpy/"/>
      <url>/2025/01/23/%E5%85%B3%E4%BA%8Enumpy/</url>
      
        <content type="html"><![CDATA[<h1 id="Numpy-Ndarray-对象"><a href="#Numpy-Ndarray-对象" class="headerlink" title="Numpy Ndarray 对象"></a>Numpy Ndarray 对象</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.array(<span class="built_in">object</span>, dtype = <span class="literal">None</span>, copy = <span class="literal">True</span>, order = <span class="literal">None</span>, subok = <span class="literal">False</span>, ndmin = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>参数说明：</p><div class="table-container"><table><thead><tr><th style="text-align:left"><font style="color:rgb(51, 51, 51);">参数</font></th><th style="text-align:left"><font style="color:rgb(51, 51, 51);">说明</font></th></tr></thead><tbody><tr><td style="text-align:left"><font style="color:rgb(51, 51, 51);">object</font></td><td style="text-align:left"><font style="color:rgb(51, 51, 51);">数组或嵌套的数列</font></td></tr><tr><td style="text-align:left"><font style="color:rgb(51, 51, 51);">dtype</font></td><td style="text-align:left"><font style="color:rgb(51, 51, 51);">数组元素的数据类型，可选</font></td></tr><tr><td style="text-align:left"><font style="color:rgb(51, 51, 51);">copy</font></td><td style="text-align:left"><font style="color:rgb(51, 51, 51);">对象是否需要复制，可选</font></td></tr><tr><td style="text-align:left"><font style="color:rgb(51, 51, 51);">order</font></td><td style="text-align:left"><font style="color:rgb(51, 51, 51);">创建数组的样式，C为行方向，F为列方向，A为任意方向（默认）</font></td></tr><tr><td style="text-align:left"><font style="color:rgb(51, 51, 51);">subok</font></td><td style="text-align:left"><font style="color:rgb(51, 51, 51);">默认返回一个与基类类型一致的数组</font></td></tr><tr><td style="text-align:left"><font style="color:rgb(51, 51, 51);">ndmin</font></td><td style="text-align:left"><font style="color:rgb(51, 51, 51);">指定生成数组的最小维度</font></td></tr></tbody></table></div><p>每个内建类型都有一个唯一定义他的字符代码</p><div class="table-container"><table><thead><tr><th><font style="color:rgb(255, 255, 255);">字符</font></th><th><font style="color:rgb(255, 255, 255);">对应类型</font></th></tr></thead><tbody><tr><td><font style="color:rgb(51, 51, 51);">b</font></td><td><font style="color:rgb(51, 51, 51);">布尔型</font></td></tr><tr><td><font style="color:rgb(51, 51, 51);">i</font></td><td><font style="color:rgb(51, 51, 51);">(有符号) 整型</font></td></tr><tr><td><font style="color:rgb(51, 51, 51);">u</font></td><td><font style="color:rgb(51, 51, 51);">无符号整型 integer</font></td></tr><tr><td><font style="color:rgb(51, 51, 51);">f</font></td><td><font style="color:rgb(51, 51, 51);">浮点型</font></td></tr><tr><td><font style="color:rgb(51, 51, 51);">c</font></td><td><font style="color:rgb(51, 51, 51);">复数浮点型</font></td></tr><tr><td><font style="color:rgb(51, 51, 51);">m</font></td><td><font style="color:rgb(51, 51, 51);">timedelta（时间间隔）</font></td></tr><tr><td><font style="color:rgb(51, 51, 51);">M</font></td><td><font style="color:rgb(51, 51, 51);">datetime（日期时间）</font></td></tr><tr><td><font style="color:rgb(51, 51, 51);">O</font></td><td><font style="color:rgb(51, 51, 51);">(Python) 对象</font></td></tr><tr><td><font style="color:rgb(51, 51, 51);">S, a</font></td><td><font style="color:rgb(51, 51, 51);">(byte-)字符串</font></td></tr><tr><td><font style="color:rgb(51, 51, 51);">U</font></td><td><font style="color:rgb(51, 51, 51);">Unicode</font></td></tr><tr><td><font style="color:rgb(51, 51, 51);">V</font></td><td><font style="color:rgb(51, 51, 51);">原始数据 (void)</font></td></tr></tbody></table></div><h1 id="Numpy数组属性"><a href="#Numpy数组属性" class="headerlink" title="Numpy数组属性"></a><font style="color:rgb(51, 51, 51);">Numpy数组属性</font></h1><font style="color:rgb(51, 51, 51);">NumPy 数组的维数称为秩（rank），秩就是轴的数量，即数组的维度，一维数组的秩为 1，二维数组的秩为 2，以此类推。</font><font style="color:rgb(51, 51, 51);">在 NumPy中，每一个线性的数组称为是一个轴（axis），也就是维度（dimensions）。比如说，二维数组相当于是两个一维数组，其中第一个一维数组中每个元素又是一个一维数组。所以一维数组就是 NumPy 中的轴（axis），第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量——秩，就是数组的维数。</font><font style="color:rgb(51, 51, 51);">很多时候可以声明 axis。axis=0，表示沿着第 0 轴进行操作，即对每一列进行操作；axis=1，表示沿着第1轴进行操作，即对每一行进行操作</font><div class="table-container"><table><thead><tr><th><font style="color:rgb(255, 255, 255);">属性</font></th><th><font style="color:rgb(255, 255, 255);">说明</font></th></tr></thead><tbody><tr><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;ndarray.ndim&lt;/font&gt;</code></td><td><font style="color:rgb(51, 51, 51);">数组的秩（rank），即数组的维度数量或轴的数量。</font></td></tr><tr><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;ndarray.shape&lt;/font&gt;</code></td><td><font style="color:rgb(51, 51, 51);">数组的维度，表示数组在每个轴上的大小。对于二维数组（矩阵），表示其行数和列数。</font></td></tr><tr><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;ndarray.size&lt;/font&gt;</code></td><td><font style="color:rgb(51, 51, 51);">数组中元素的总个数，等于</font><font style="color:rgb(51, 51, 51);"> </font><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;ndarray.shape&lt;/font&gt;</code><br/><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">中各个轴上大小的乘积。</font></td></tr><tr><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;ndarray.dtype&lt;/font&gt;</code></td><td><font style="color:rgb(51, 51, 51);">数组中元素的数据类型。</font></td></tr><tr><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;ndarray.itemsize&lt;/font&gt;</code></td><td><font style="color:rgb(51, 51, 51);">数组中每个元素的大小，以字节为单位。</font></td></tr><tr><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;ndarray.flags&lt;/font&gt;</code></td><td><font style="color:rgb(51, 51, 51);">包含有关内存布局的信息，如是否为 行优先 或 列优先 连续存储，是否为只读等。</font></td></tr><tr><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;ndarray.real&lt;/font&gt;</code></td><td><font style="color:rgb(51, 51, 51);">数组中每个元素的实部（如果元素类型为复数）。</font></td></tr><tr><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;ndarray.imag&lt;/font&gt;</code></td><td><font style="color:rgb(51, 51, 51);">数组中每个元素的虚部（如果元素类型为复数）。</font></td></tr><tr><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;ndarray.data&lt;/font&gt;</code></td><td><font style="color:rgb(51, 51, 51);">实际存储数组元素的缓冲区，一般通过索引访问元素，不直接使用该属性。</font></td></tr></tbody></table></div><blockquote><p>ndarray.flags</p><p>C_CONTIGUOUS (C)：表示数组在内存中按 C 语言风格（行优先）连续存储。</p><p>F_CONTIGUOUS (F)：表示数组在内存中按 Fortran 语言风格（列优先）连续存储。</p><p>OWNDATA (O)：表示数组拥有自己的数据缓冲区，而不是借用其他对象的数据。</p><p>WRITEABLE (W)：表示数组是否可以被修改。</p><p>ALIGNED (A)：表示数组的数据元素是否按照硬件要求对齐。</p><p>UPDATEIFCOPY (U)：表示当数组副本被修改时，原始数组是否会被更新（此标志已弃用）</p></blockquote><h1 id="Numpy-创建数组"><a href="#Numpy-创建数组" class="headerlink" title="Numpy 创建数组"></a>Numpy 创建数组</h1><p>使用底层ndarray构造器来创建</p><h3 id="Numpy-empty"><a href="#Numpy-empty" class="headerlink" title="Numpy.empty :"></a>Numpy.empty :</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.empty(shape,dtype = <span class="built_in">float</span>,order = <span class="string">&quot;C&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="numpy-zeros-like"><a href="#numpy-zeros-like" class="headerlink" title="numpy.zeros_like"></a><font style="color:rgb(51, 51, 51);">numpy.zeros_like</font></h3><font style="color:rgb(51, 51, 51);">numpy.zeros_like 用于创建一个与给定数组具有相同形状的数组，数组元素以 0 来填充。</font><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.zeros_like(a, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;K&#x27;</span>, subok=<span class="literal">True</span>, shape=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><font style="color:rgb(255, 255, 255);">》</font><div class="table-container"><table><thead><tr><th style="text-align:left"><font style="color:rgb(255, 255, 255);">参数</font></th><th style="text-align:left"><font style="color:rgb(255, 255, 255);">描述</font></th></tr></thead><tbody><tr><td style="text-align:left"><font style="color:rgb(51, 51, 51);">a</font></td><td style="text-align:left"><font style="color:rgb(51, 51, 51);">给定要创建相同形状的数组</font></td></tr><tr><td style="text-align:left"><font style="color:rgb(51, 51, 51);">dtype</font></td><td style="text-align:left"><font style="color:rgb(51, 51, 51);">创建的数组的数据类型</font></td></tr><tr><td style="text-align:left"><font style="color:rgb(51, 51, 51);">order</font></td><td style="text-align:left"><font style="color:rgb(51, 51, 51);">数组在内存中的存储顺序，可选值为 ‘C’（按行优先）或 ‘F’（按列优先），默认为 ‘K’（保留输入数组的存储顺序）</font></td></tr><tr><td style="text-align:left"><font style="color:rgb(51, 51, 51);">subok</font></td><td style="text-align:left"><font style="color:rgb(51, 51, 51);">是否允许返回子类，如果为 True，则返回一个子类对象，否则返回一个与 a 数组具有相同数据类型和存储顺序的数组</font></td></tr><tr><td style="text-align:left"><font style="color:rgb(51, 51, 51);">shape</font></td><td style="text-align:left"><font style="color:rgb(51, 51, 51);">创建的数组的形状，如果不指定，则默认为 a 数组的形状。</font></td></tr></tbody></table></div><h3 id="numpy-ones-like"><a href="#numpy-ones-like" class="headerlink" title="numpy.ones_like"></a><font style="color:rgb(51, 51, 51);">numpy.ones_like</font></h3><p>pass</p><h1 id="Numpy-从已有数组创建数组"><a href="#Numpy-从已有数组创建数组" class="headerlink" title="Numpy 从已有数组创建数组"></a>Numpy 从已有数组创建数组</h1><h3 id="numpy-asarray"><a href="#numpy-asarray" class="headerlink" title="numpy.asarray"></a>numpy.asarray</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.asarray(a, dtype = <span class="literal">None</span>, order = <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th><font style="color:rgb(255, 255, 255);">参数</font></th><th><font style="color:rgb(255, 255, 255);">描述</font></th></tr></thead><tbody><tr><td><font style="color:rgb(51, 51, 51);">a</font></td><td><font style="color:rgb(51, 51, 51);">任意形式的输入参数，可以是，列表, 列表的元组, 元组, 元组的元组, 元组的列表，多维数组</font></td></tr><tr><td><font style="color:rgb(51, 51, 51);">dtype</font></td><td><font style="color:rgb(51, 51, 51);">数据类型，可选</font></td></tr><tr><td><font style="color:rgb(51, 51, 51);">order</font></td><td><font style="color:rgb(51, 51, 51);">可选，有”C”和”F”两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。</font></td></tr></tbody></table></div><h3 id="numpy-frombuffer"><a href="#numpy-frombuffer" class="headerlink" title="numpy.frombuffer"></a><font style="color:rgb(51, 51, 51);">numpy.frombuffer</font></h3><font style="color:rgb(51, 51, 51);">numpy.frombuffer 用于实现动态数组。</font><font style="color:rgb(51, 51, 51);">numpy.frombuffer 接受 buffer 输入参数，以流的形式读入转化成 ndarray 对象。</font><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.frombuffer(buffer, dtype = <span class="built_in">float</span>, count = -<span class="number">1</span>, offset = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th><font style="color:rgb(255, 255, 255);">参数</font></th><th><font style="color:rgb(255, 255, 255);">描述</font></th></tr></thead><tbody><tr><td><font style="color:rgb(51, 51, 51);">buffer</font></td><td><font style="color:rgb(51, 51, 51);">可以是任意对象，会以流的形式读入。</font></td></tr><tr><td><font style="color:rgb(51, 51, 51);">dtype</font></td><td><font style="color:rgb(51, 51, 51);">返回数组的数据类型，可选</font></td></tr><tr><td><font style="color:rgb(51, 51, 51);">count</font></td><td><font style="color:rgb(51, 51, 51);">读取的数据数量，默认为-1，读取所有数据。</font></td></tr><tr><td><font style="color:rgb(51, 51, 51);">offset</font></td><td><font style="color:rgb(51, 51, 51);">读取的起始位置，默认为0。</font></td></tr></tbody></table></div><blockquote><p><em><strong><font style="color:rgb(51, 51, 51);">注意：</font></strong>__<font style="color:rgb(51, 51, 51);background-color:rgb(243, 247, 240);">buffer 是字符串的时候，Python3 默认 str 是 Unicode 类型，所以要转成 bytestring 在原 str 前加上 b。</font></em></p></blockquote><h3 id="numpy-fromiter"><a href="#numpy-fromiter" class="headerlink" title="numpy.fromiter"></a><font style="color:rgb(51, 51, 51);">numpy.fromiter</font></h3><p>从可迭代对象创建ndarray对象，返回一维数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.fromiter(iterable, dtype, count=-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th><font style="color:rgb(255, 255, 255);">参数</font></th><th><font style="color:rgb(255, 255, 255);">描述</font></th></tr></thead><tbody><tr><td><font style="color:rgb(51, 51, 51);">iterable</font></td><td><font style="color:rgb(51, 51, 51);">可迭代对象</font></td></tr><tr><td><font style="color:rgb(51, 51, 51);">dtype</font></td><td><font style="color:rgb(51, 51, 51);">返回数组的数据类型</font></td></tr><tr><td><font style="color:rgb(51, 51, 51);">count</font></td><td><font style="color:rgb(51, 51, 51);">读取的数据数量，默认为-1，读取所有数据</font></td></tr></tbody></table></div><h1 id="Numpy-从数值范围创建数组"><a href="#Numpy-从数值范围创建数组" class="headerlink" title="Numpy 从数值范围创建数组"></a>Numpy 从数值范围创建数组</h1><h3 id="numpy-arange"><a href="#numpy-arange" class="headerlink" title="numpy.arange"></a>numpy.arange</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.arange(start,stop,atep,dtype)</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th><font style="color:rgb(255, 255, 255);">参数</font></th><th><font style="color:rgb(255, 255, 255);">描述</font></th></tr></thead><tbody><tr><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;start&lt;/font&gt;</code></td><td><font style="color:rgb(51, 51, 51);">起始值，默认为</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;0&lt;/font&gt;</code></td></tr><tr><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;stop&lt;/font&gt;</code></td><td><font style="color:rgb(51, 51, 51);">终止值（不包含）</font></td></tr><tr><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;step&lt;/font&gt;</code></td><td><font style="color:rgb(51, 51, 51);">步长，默认为</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;1&lt;/font&gt;</code></td></tr><tr><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;dtype&lt;/font&gt;</code></td><td><font style="color:rgb(51, 51, 51);">返回</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;ndarray&lt;/font&gt;</code><br/><font style="color:rgb(51, 51, 51);">的数据类型，如果没有提供，则会使用输入数据的类型。</font></td></tr></tbody></table></div><h3 id="numpy-linispace"><a href="#numpy-linispace" class="headerlink" title="numpy.linispace"></a>numpy.linispace</h3><p>创建一个等差数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.linspace(start,stop,num=50endpoint=<span class="literal">True</span>,dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th><font style="color:rgb(255, 255, 255);">参数</font></th><th><font style="color:rgb(255, 255, 255);">描述</font></th></tr></thead><tbody><tr><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;start&lt;/font&gt;</code></td><td><font style="color:rgb(51, 51, 51);">序列的起始值</font></td></tr><tr><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;stop&lt;/font&gt;</code></td><td><font style="color:rgb(51, 51, 51);">序列的终止值，如果</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;endpoint&lt;/font&gt;</code><br/><font style="color:rgb(51, 51, 51);">为</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;true&lt;/font&gt;</code><br/><font style="color:rgb(51, 51, 51);">，该值包含于数列中</font></td></tr><tr><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;num&lt;/font&gt;</code></td><td><font style="color:rgb(51, 51, 51);">要生成的等步长的样本数量，默认为</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;50&lt;/font&gt;</code></td></tr><tr><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;endpoint&lt;/font&gt;</code></td><td><font style="color:rgb(51, 51, 51);">该值为</font><font style="color:rgb(51, 51, 51);"> </font><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;true&lt;/font&gt;</code><br/><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">时，数列中包含</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;stop&lt;/font&gt;</code><br/><font style="color:rgb(51, 51, 51);">值，反之不包含，默认是True。</font></td></tr><tr><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;retstep&lt;/font&gt;</code></td><td><font style="color:rgb(51, 51, 51);">如果为 True 时，生成的数组中会显示间距，反之不显示。</font></td></tr><tr><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;dtype&lt;/font&gt;</code></td><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;ndarray&lt;/font&gt;</code><br/><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">的数据类型</font></td></tr></tbody></table></div><h3 id="numpy-logspace"><a href="#numpy-logspace" class="headerlink" title="numpy.logspace"></a><font style="color:rgb(51, 51, 51);">numpy.logspace</font></h3><font style="color:rgb(51, 51, 51);">numpy.logspace 函数用于创建一个于等比数列</font><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.logspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, base=<span class="number">10.0</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th><font style="color:rgb(255, 255, 255);">参数</font></th><th><font style="color:rgb(255, 255, 255);">描述</font></th></tr></thead><tbody><tr><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;start&lt;/font&gt;</code></td><td><font style="color:rgb(51, 51, 51);">序列的起始值为：base ** start</font></td></tr><tr><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;stop&lt;/font&gt;</code></td><td><font style="color:rgb(51, 51, 51);">序列的终止值为：base ** stop。如果</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;endpoint&lt;/font&gt;</code><br/><font style="color:rgb(51, 51, 51);">为</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;true&lt;/font&gt;</code><br/><font style="color:rgb(51, 51, 51);">，该值包含于数列中</font></td></tr><tr><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;num&lt;/font&gt;</code></td><td><font style="color:rgb(51, 51, 51);">要生成的等步长的样本数量，默认为</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;50&lt;/font&gt;</code></td></tr><tr><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;endpoint&lt;/font&gt;</code></td><td><font style="color:rgb(51, 51, 51);">该值为</font><font style="color:rgb(51, 51, 51);"> </font><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;true&lt;/font&gt;</code><br/><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">时，数列中中包含</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;stop&lt;/font&gt;</code><br/><font style="color:rgb(51, 51, 51);">值，反之不包含，默认是True。</font></td></tr><tr><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;base&lt;/font&gt;</code></td><td><font style="color:rgb(51, 51, 51);">对数 log 的底数。</font></td></tr><tr><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;dtype&lt;/font&gt;</code></td><td><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;ndarray&lt;/font&gt;</code><br/><font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">的数据类型</font></td></tr></tbody></table></div><h1 id="Numpy切片和索引"><a href="#Numpy切片和索引" class="headerlink" title="Numpy切片和索引"></a>Numpy切片和索引</h1><p>ndarray对象可以通过索引和切片来修改和访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">slice</span>(start,stop,step) <span class="comment"># 开始 结束 步长</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = numpy .arrange(<span class="number">10</span>)</span><br><span class="line">b = a[<span class="number">2</span>:<span class="number">7</span>:<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 通过[]进行切片，start:stop:step</span></span><br></pre></td></tr></table></figure><p>切片还可以包括省略号<strong><font style="color:rgb(51, 51, 51);background-color:rgb(236, 234, 230);">,</font></strong><font style="color:rgb(51, 51, 51);">来使选择元组的长度与数组的维度相同。 如果在行位置使用省略号，它将返回包含行中元素的 ndarray。</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])  </span><br><span class="line"><span class="built_in">print</span> (a[...,<span class="number">1</span>])   <span class="comment"># 第2列元素</span></span><br><span class="line"><span class="built_in">print</span> (a[<span class="number">1</span>,...])   <span class="comment"># 第2行元素</span></span><br><span class="line"><span class="built_in">print</span> (a[...,<span class="number">1</span>:])  <span class="comment"># 第2列及剩下的所有元素</span></span><br></pre></td></tr></table></figure><p><em><font style="color:rgb(51, 51, 51);background-color:rgb(243, 247, 240);"></font></em></p><font style="color:rgb(255, 255, 255);">></font>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python学习四大剑客</title>
      <link href="/2025/01/23/python%E5%AD%A6%E4%B9%A0%E5%9B%9B%E5%A4%A7%E5%89%91%E5%AE%A2/"/>
      <url>/2025/01/23/python%E5%AD%A6%E4%B9%A0%E5%9B%9B%E5%A4%A7%E5%89%91%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>python在深度学习方面主要有四个常用的模块。主要是numpy,pandas,matplotlib,PIL</p></blockquote><h2 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h2><blockquote><p>Numpy是Python科学计算库的基础。包含了强大的N维数组对象和向量运算</p><ul><li>ndarray，一个具有矢量算术运算和复杂广播能力的快速且节省空间的多维数组。</li><li>用于对整组数据进行快速运算的标准数学函数（无需编写循环）。</li><li>用于读写磁盘数据的工具以及用于操作内存映射文件的工具。</li><li>线性代数、随机数生成以及傅里叶变换功能。</li><li>用于集成由C、C++、Fortran等语言编写的代码的工具</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建ndarray数组</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">b = numpy.array(a)</span><br><span class="line"><span class="comment"># print(b)</span></span><br><span class="line"><span class="comment"># zeros和ones能创建制定长度或者形状的全为0或1的数组</span></span><br><span class="line"><span class="comment"># Empty可以创建空数组</span></span><br><span class="line">arr_zero = numpy.zeros([<span class="number">10</span>,<span class="number">10</span>]) <span class="comment"># 创建10 * 10 值为0的矩阵</span></span><br><span class="line">arr_one = numpy.ones([<span class="number">10</span>,<span class="number">10</span>]) <span class="comment">#  创建10 * 10 值为1的矩阵</span></span><br><span class="line"><span class="comment"># print(arr_one)</span></span><br><span class="line"><span class="comment"># print(arr_zero)</span></span><br><span class="line"><span class="comment"># 创建随机数组</span></span><br><span class="line"><span class="comment"># 均匀分布</span></span><br><span class="line"><span class="comment"># 创建一个10 * 10 的数组，值在0 - 1之间</span></span><br><span class="line">arr_rand = numpy.random.rand(<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line"><span class="comment"># print(arr_rand)</span></span><br><span class="line"><span class="comment"># 创建制定范围内的一个数</span></span><br><span class="line">arr_unfinm = numpy.random.uniform(<span class="number">0</span>,<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 创建制定范围内的一个整数</span></span><br><span class="line">arr_int = numpy.random.randint(<span class="number">0</span>,<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 创建一个（2,3）维度，均值为1.75，标准差为0.1的正态分布数组</span></span><br><span class="line">arr_normal = numpy.random.normal(<span class="number">1.75</span>,<span class="number">0.1</span>,(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment"># print(arr_normal)</span></span><br><span class="line"><span class="comment"># print(arr_int)</span></span><br><span class="line"><span class="comment"># print(arr_unfinm)</span></span><br><span class="line"><span class="comment"># 数组的方法</span></span><br><span class="line"><span class="comment"># 数组元素个数</span></span><br><span class="line">arr_size = arr_normal.size</span><br><span class="line"><span class="built_in">print</span>(arr_size)</span><br><span class="line"><span class="comment"># 数组的形状</span></span><br><span class="line">arr_shape = arr_rand.shape</span><br><span class="line"><span class="built_in">print</span>(arr_shape)</span><br><span class="line"><span class="comment"># 数组的维度</span></span><br><span class="line">arr_mode = arr_normal.ndim</span><br><span class="line"><span class="built_in">print</span>(arr_mode)</span><br><span class="line"><span class="comment"># 数组元素类型</span></span><br><span class="line">arr_type = arr_normal.dtype</span><br><span class="line"><span class="built_in">print</span>(arr_type)</span><br></pre></td></tr></table></figure><p>数组的重要性在于，不用进行循环，我们就可以对数据进行批量运算。这种方式我们通常叫做 <strong>矢量化</strong></p><p>数组基础</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">one_list = np.ones([<span class="number">3</span>,<span class="number">5</span>],dtype=<span class="built_in">int</span>)</span><br><span class="line">pi_list = np.full([<span class="number">3</span>,<span class="number">5</span>],<span class="number">3.14</span>)</span><br><span class="line"><span class="comment"># 创建一个线性数组    起点，终止，步长</span></span><br><span class="line">arr_list = np.arange(<span class="number">0</span>,<span class="number">20</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 生成一个[0~1]之间的随机数</span></span><br><span class="line">a1 = np.random.random()</span><br><span class="line"><span class="comment"># 生成包含两个元素的np数组</span></span><br><span class="line">a2 = np.random.random(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 生成一个3 x 3 的矩阵，元素范围是【0~1】</span></span><br><span class="line">a3 = np.random.random((<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 生成一个3X3X3 的矩阵，元素范围是【0~1】</span></span><br><span class="line">a4 = np.random.random((<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 创建一个2X2的浮点数数组，范围是【5~7】</span></span><br><span class="line">a5 = np.random.uniform(<span class="number">5</span>,<span class="number">7</span>,(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"><span class="comment"># 创建一个2X2的正数数组，范围是【5~7】</span></span><br><span class="line">a6 = np.random.randint(<span class="number">5</span>,<span class="number">7</span>,(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"><span class="comment"># 创建一个 3X3 ，均值为0，标准差为1 ，符合正态分布的随机整数数组，np.random.normal(均值，标准差，形状)-------正态分布概率密度函数</span></span><br><span class="line">list1 = np.random.normal(<span class="number">0</span>,<span class="number">1</span>,(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 创建一个3x3 的数组，包含正态分布的随机数</span></span><br><span class="line">list2 = np.random.randn(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 创建一个3X3 的单位矩阵</span></span><br><span class="line">list3 = np.eye(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 创建一个由3个整数数组组成的未初始化的数组，数组的值是中间的人任意值</span></span><br><span class="line">list4 = np.empty(<span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数组属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置随机种子，确保程序每次执行生成的随机数组相同</span></span><br><span class="line">ls1 = np.random.seed(<span class="number">0</span>)</span><br><span class="line">x1 = np.random.randint(<span class="number">10</span>,size = <span class="number">6</span>)</span><br><span class="line">x2 = np.random.randint(<span class="number">10</span>,size = (<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">x3 = np.random.randint(<span class="number">10</span>,size = (<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x3_ndim = x3.ndim <span class="comment"># 数组的维度或秩</span></span><br><span class="line">x3_shape = x3.shape <span class="comment"># 数组的形状，每个维度的大小</span></span><br><span class="line">x3_size = x3.size <span class="comment"># 数组的总大小，各个的乘积</span></span><br><span class="line">x3_dtype = x3.dtype <span class="comment"># 数组的数据类型</span></span><br><span class="line">x3_itemsize = x3.itemsize <span class="comment"># 每个数组元素字节大小</span></span><br><span class="line">x3_nbytes = x3.nbytes  <span class="comment"># 数组总字节大小， 一般nbytes = intemsize * shape</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x3_ndim&quot;</span>,x3_ndim)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x3_shape&quot;</span>,x3_shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x3_size&quot;</span>,x3_size)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x3_dtype&quot;</span>,x3_dtype)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x3_itemsize&quot;</span>,x3_itemsize)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x3_nbytes&quot;</span>,x3_nbytes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组切片</span></span><br><span class="line"><span class="built_in">print</span>(x1)</span><br><span class="line"><span class="built_in">print</span>(x1[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(x3)</span><br><span class="line"><span class="built_in">print</span>(x3[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用索引修改数组的元素值,浮点数插入整型数组时会自动截短</span></span><br><span class="line">x3[<span class="number">2</span>][<span class="number">2</span>][<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(x3)</span><br><span class="line">x3[<span class="number">2</span>][<span class="number">2</span>][<span class="number">0</span>] = <span class="number">3.1415</span></span><br><span class="line">x3</span><br></pre></td></tr></table></figure><h3 id="数组的基本索引和切片"><a href="#数组的基本索引和切片" class="headerlink" title="数组的基本索引和切片"></a>数组的基本索引和切片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nunpy 数组的切片</span></span><br><span class="line"><span class="comment"># 一维数组</span></span><br><span class="line">arr_first_demin = numpy.arange(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(arr_first_demin)</span><br><span class="line"><span class="comment"># 一维数组的功能和Python的列表功能差不多</span></span><br><span class="line"><span class="comment"># 按索引取值</span></span><br><span class="line"><span class="built_in">print</span>(arr_first_demin[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 切片</span></span><br><span class="line">new_arr = arr_first_demin[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(new_arr)</span><br><span class="line"><span class="comment"># 如果将一个标量赋值给一个切片，该值自动传播至整个选区</span></span><br><span class="line">arr_first_demin[<span class="number">2</span>:<span class="number">6</span>] = <span class="number">12</span></span><br><span class="line"><span class="built_in">print</span>(arr_first_demin)</span><br><span class="line"><span class="comment"># 和Python列表不同的是，数组切片是在原始数组的基础上进行的，修改切片也会影响原来的数组。</span></span><br><span class="line">new_arr[<span class="number">0</span>] = <span class="number">15</span></span><br><span class="line"><span class="built_in">print</span>(arr_first_demin)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组变形</span></span><br><span class="line">grid = np.arange(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(grid)</span><br><span class="line">grid_reshape = grid.reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(grid_reshape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment"># 利用reshape 或 newaxis 切片 将一维数组变为二维单行数组</span></span><br><span class="line"><span class="built_in">print</span>(x.reshape(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(x[np.newaxis,:])</span><br><span class="line"><span class="comment"># 利用reshape 或 newaxis 切片将一维数组变为二维单列数组</span></span><br><span class="line"><span class="built_in">print</span>(x.reshape(<span class="number">3</span>,<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(x[:,np.newaxis])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组的拼接</span></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">y = np.array([<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line">z = np.array([<span class="number">99</span>,<span class="number">99</span>,<span class="number">99</span>])</span><br><span class="line"><span class="built_in">print</span>(np.concatenate([x,y,z]))</span><br><span class="line"><span class="comment"># 对于二维数组的拼接，np.concattanatate([x,y],axis默认是沿着行的方向对每列操作，1是沿着列方向对每行操作)要求维度相同</span></span><br><span class="line">grid = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                 [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(np.concatenate([grid,grid]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.concatenate([grid,grid],axis = <span class="number">1</span>))</span><br><span class="line"><span class="comment"># np.vstack水平栈同axis=0</span></span><br><span class="line"><span class="built_in">print</span>(np.vstack([x,y,z,grid]))</span><br><span class="line"><span class="comment"># np.hstack水平栈同axis=1</span></span><br><span class="line"><span class="built_in">print</span>(np.hstack([grid,grid]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">x1 ,x2 ,x3 = np.split(x,[<span class="number">3</span>,<span class="number">5</span>]) <span class="comment"># np.split(x,[索引记录断点的位置，N个分裂点得到N+1个数组])</span></span><br><span class="line"></span><br><span class="line">y = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">              [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">              [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"><span class="comment"># 沿行方向平均分裂成3个数组</span></span><br><span class="line"><span class="built_in">print</span>(np.split(y,<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 沿列方向平均分裂成3个数组</span></span><br><span class="line"><span class="built_in">print</span>(np.split(y,<span class="number">3</span>,axis = <span class="number">1</span>))</span><br><span class="line"><span class="comment"># 沿行方向平均分裂成3个数组</span></span><br><span class="line"><span class="built_in">print</span>(np.split(y,[<span class="number">1</span>,<span class="number">2</span>]))</span><br><span class="line">grid = np.arange(<span class="number">16</span>).reshape(<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(grid)</span><br><span class="line">upper,mindder,lower = np.vsplit(grid,[<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(upper)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mindder = \n&quot;</span>,mindder)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;lower&quot;</span>,lower)</span><br><span class="line">left ,right = np.hsplit(grid,[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(left)</span><br><span class="line"><span class="built_in">print</span>(right)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在多维数组中索引位置上就有可能是一个数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">arr3d = numpy.array([[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]], [[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]])</span><br><span class="line"><span class="built_in">print</span>(arr3d)</span><br><span class="line">arr_first = arr3d[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(arr_first)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问第一行第一个元素</span></span><br><span class="line">arr_first_get = arr3d[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(arr_first_get)</span><br><span class="line"><span class="comment"># 访问第一行第一个元素</span></span><br><span class="line">arr_first_get2 = arr3d[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(arr_first_get2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="numpy的数学统计"><a href="#numpy的数学统计" class="headerlink" title="numpy的数学统计"></a>numpy的数学统计</h3><p>数组的运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数组的运算</span></span><br><span class="line">x = np.arange(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x    = &quot;</span> ,x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; x+5 =&quot;</span>,x +<span class="number">5</span>,np.add(x,<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; x-5 =&quot;</span>,x-<span class="number">5</span>,np.subtract(x,<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x * 2 = &quot;</span>,x * <span class="number">2</span>,np.multiply(x,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x / 2 =&quot;</span>,x / <span class="number">2</span>,np.divide(x,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x // 2 = &quot;</span>,x //<span class="number">2</span> ,np.floor_divide(x,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x % 2=&quot;</span>,x%<span class="number">2</span>,np.mod(x,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x ** 2=&quot;</span> ,x**<span class="number">2</span>,np.power(x,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-x =&#x27;</span>,-x,np.negative(x))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-(0.5*x + 1) ** 2= &#x27;</span>,-(<span class="number">0.5</span>*x +<span class="number">1</span>)**<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>绝对值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绝对值</span></span><br><span class="line">x = np.array([-<span class="number">2</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">abs</span>(x))</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">abs</span>(x))</span><br><span class="line"><span class="built_in">print</span>(np.absolute(x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复数的绝对值返回复数的模，即复数的实部和虚部的平方和的平方根</span></span><br><span class="line">y = np.array([<span class="number">3</span>-<span class="number">4j</span>,<span class="number">4</span>-<span class="number">3j</span>,<span class="number">2</span>+<span class="number">0j</span>,<span class="number">0</span>+<span class="number">1j</span>])</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">abs</span>(y))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>三角函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 三角函数和逆三角函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy.linspace(start, stop, num=50, endpoint=True(stop值包含在数组中), retstep=False, dtype=None, axis=0)</span></span><br><span class="line"><span class="comment"># np.pi = π</span></span><br><span class="line">theta = np.linspace(<span class="number">0</span>,np.pi,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(theta)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sin(theta) = &#x27;</span>, np.sin(theta))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;cos(theta) = &#x27;</span>,np.cos(theta))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;tan(theta) = &#x27;</span>,np.tan(theta))</span><br><span class="line">x = [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x = &#x27;</span>,x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;arcsin(x)&#x27;</span>,np.arcsin(x))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;arccos(x)&#x27;</span>,np.arccos(x))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;arctan(x)&#x27;</span>,np.arctan(x))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>指数和对数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指数和对数</span></span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e^x = &quot;</span>,np.exp(x))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;2^x = &#x27;</span>,np.exp2(x))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;3^x = &#x27;</span>,np.power(<span class="number">3</span>,x))</span><br><span class="line"><span class="built_in">print</span>(np.power(<span class="number">2</span>,x))</span><br><span class="line">y = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">10</span>]</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ln(x) = &quot;</span>,np.log(x))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;log2(x)=&quot;</span>,np.log2(x))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;log10(x)=&quot;</span>,np.log10(x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特殊版本，当输入值非常小时，用特殊函数给出的值比np.log和np.exp计算更精确</span></span><br><span class="line">z = [<span class="number">0</span>, <span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;exp(z) - 1 =&#x27;</span>,np.expm1(z))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;log(l + z ) = &#x27;</span>,np.log1p(z))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>高级通用函数特性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 高级通用函数特性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定输出位置：所有通用函数都可以用out参数指定计算结果的存放位置</span></span><br><span class="line">x = np.arange(<span class="number">5</span>)</span><br><span class="line">y = np.empty(<span class="number">5</span>)</span><br><span class="line">np.multiply(x,<span class="number">10</span>,out = y)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="comment"># 将指定结果写入到数组的每隔一个的位置</span></span><br><span class="line">z = np.zeros(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"><span class="built_in">print</span>(np.power(<span class="number">2</span>,x,out = z[::<span class="number">2</span>]))</span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 聚合reduce:所有元素累计</span></span><br><span class="line">x = np.arange(<span class="number">1</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x = &quot;</span>,x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x 中的所有元素求和：&#x27;</span>,np.add.reduce(x))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x 中的所有元素求积：&quot;</span>,np.multiply.reduce(x))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x 中的所有元素求和并展示：&#x27;</span>,np.add.accumulate(x))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x 中的所有元素求积并展示：&#x27;</span>,np.multiply.accumulate(x))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="sum、mean等聚合运算的方法"><a href="#sum、mean等聚合运算的方法" class="headerlink" title="sum、mean等聚合运算的方法"></a>sum、mean等聚合运算的方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">arr_demin = numpy.random.randn(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(arr_demin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算平均值的两种方法</span></span><br><span class="line"><span class="comment"># sum、mean以及标准差std等聚合计算既可以当做数组的实例方法调用，也可以当做顶级Numpy函数使用</span></span><br><span class="line">arr_mean1 = arr_demin.mean()</span><br><span class="line"><span class="built_in">print</span>(arr_mean1)</span><br><span class="line"><span class="comment"># mean计算平均数</span></span><br><span class="line">arr_mean2 = numpy.mean(arr_demin)</span><br><span class="line"><span class="built_in">print</span>(arr_mean2)</span><br><span class="line">arr_std = numpy.std(arr_demin)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;arr 的标准差&quot;</span>,arr_std)</span><br></pre></td></tr></table></figure><h4 id="std方法"><a href="#std方法" class="headerlink" title="std方法"></a>std方法</h4><p>:::info<br> 参数</p><p>a：输入数组，可以是任意维度的数组。</p><p>axis：指定沿哪个轴计算标准差。默认值为None，表示计算整个数组的标准差。如果指定为整数，则沿着该轴计算标准差。</p><p>dtype：用于计算标准差的返回类型。如果不指定，则使用输入数组的类型。</p><p>out：可选参数，用于存储结果的数组。</p><p>ddof：指定用于计算标准差的自由度调整。默认值为0，表示计算总体标准差（除以N）。如果设置为1，则计算样本标准差（除以N-1），这在统计学中更常用于样本数据的标准差计算。</p><p>keepdims：如果设置为True，则返回的数组将保持输入数组的维度。默认值为False。</p><p>:::</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">arr = numpy.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">std_value = numpy.std(arr)</span><br><span class="line"><span class="built_in">print</span>(std_value)  <span class="comment"># 输出: 1.5811388300841898（近似值）</span></span><br><span class="line"><span class="comment"># 沿着特定轴计算标准差</span></span><br><span class="line"><span class="comment"># mean 和 sum 这类的函数可以接受一个 axis 参数（用于计算该轴向上的统计值），最终结果是一个少一维的数</span></span><br><span class="line">arr_2d = numpy.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">std_along_axis_0 = numpy.std(arr_2d, axis=<span class="number">0</span>)  <span class="comment"># 沿着第0轴（行）计算标准差</span></span><br><span class="line">std_along_axis_1 = numpy.std(arr_2d, axis=<span class="number">1</span>)  <span class="comment"># 沿着第1轴（列）计算标准差</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(std_along_axis_0)  <span class="comment"># 输出: [1.58113883 1.58113883 1.58113883]（近似值）</span></span><br><span class="line"><span class="built_in">print</span>(std_along_axis_1)  <span class="comment"># 输出: [1. 1.]</span></span><br></pre></td></tr></table></figure><h4 id="cumsum和cumpord"><a href="#cumsum和cumpord" class="headerlink" title="cumsum和cumpord"></a>cumsum和cumpord</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">arr_test = numpy.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line"><span class="comment"># cumsum和cumpord方法，该类方法不聚合，产生一个由中间结果产生的数组</span></span><br><span class="line">arr_sum = arr_test.cumsum(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数组按列的累加和&quot;</span>,arr_sum)</span><br><span class="line">arr_sum_row = arr_test.cumsum(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;按行累加的结果&quot;</span>,arr_sum_row)</span><br><span class="line">arr_pord_column = arr_test.cumprod(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;按行累积的结果&quot;</span>,arr_pord_column)</span><br><span class="line">arr_pord_row = arr_test.cumprod(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;按列累积的结果&quot;</span>,arr_pord_row)</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>sum</td><td>对数组中全部或某轴向的元素求和。零长度的数组的sum为0</td></tr><tr><td>mean</td><td>算术平均数。零长度的数组的mean为NaN</td></tr><tr><td>std,var</td><td>分别为标准差和方差，自由度可调（默认为n）</td></tr><tr><td>min,max</td><td>最大值和最小值</td></tr><tr><td>argmin, argmax</td><td>分别为最大和最小元素的索引</td></tr><tr><td>cumsum</td><td>所有元素的累加</td></tr><tr><td>cumprod</td><td>所有元素的累积</td></tr></tbody></table></div><h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><p>:::info<br>如矩阵乘法、矩阵分解、行列式以及其他方阵数学</p><p>numpy提供dot函数，用于矩阵计算</p><p>:::</p><div class="table-container"><table><thead><tr><th>常用linalg函数</th><th>说明</th></tr></thead><tbody><tr><td>diag</td><td>以一维数组的形式返回方阵的对角线（或非对角线）元<br/>素，或将一维数组转换为方阵（非对角线元素为0）</td></tr><tr><td>dot</td><td>矩阵乘法</td></tr><tr><td>trace</td><td>计算对角线元素的和</td></tr><tr><td>det</td><td>计算矩阵行列式</td></tr><tr><td>eig</td><td>计算方阵的特征值和特征向量</td></tr><tr><td>inv</td><td>计算方阵的逆</td></tr><tr><td>pinv</td><td>计算矩阵的Mooer-Penrose伪逆</td></tr><tr><td>qr</td><td>计算OR分解</td></tr><tr><td>svd</td><td>计算奇异值分解（SVD）</td></tr><tr><td>solve</td><td>解线性方程组Ax=b，其中A为一个方阵</td></tr><tr><td>lstsq</td><td>计算Ax=b的最小二乘解</td></tr></tbody></table></div><h2 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h2><ul><li>pandas有两大数据核心结构，<strong>series</strong> 一维数据，<strong>dataframe 多特征数据</strong></li></ul><p>:::info<br>pandas是建立在numpy基础上的高效数据分析处理库，是Python的重要数据分析库</p><p>提供高性能数据类型和数据分析工具</p><p>:::</p><ul><li>pandas基于numpy实现常与numpy和matplotlib一起使用</li><li><img src="https://cdn.nlark.com/yuque/0/2024/png/42731236/1731580755525-0c0df402-3181-4d7e-a6db-7a835e5223e9.png" alt=""><img src="https://cdn.nlark.com/yuque/0/2024/png/42731236/1731580767968-6426e2b8-b26d-488a-b2fb-b0865017a0cc.png" alt=""></li></ul><h3 id="series"><a href="#series" class="headerlink" title="series"></a>series</h3><p>:::info<br>series是一种类似于一维数组的对象，由一维数组（各种numpy的数据类型）和一组相对应的标签（索引）组成</p><p>:::</p><blockquote><p>创建series的方法：</p><p>Python数组</p><p>numpy数组</p><p>Python字典</p></blockquote><p><em>与Python的字典不同，series允许索引重复</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> pandas</span><br><span class="line"><span class="comment"># 使用python列表创建series对象</span></span><br><span class="line">arr_fir = pandas.Series([<span class="number">11</span>,<span class="number">12</span>],index=[<span class="string">&quot;new youk&quot;</span>,<span class="string">&quot;woshington&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(arr_fir)</span><br><span class="line"><span class="comment"># 使用numpy数组创建series对象,索引从0开始</span></span><br><span class="line">arr_numpy = pandas.Series(numpy.arange(<span class="number">3</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(arr_numpy)</span><br><span class="line"><span class="comment"># 使用Python字典创建</span></span><br><span class="line">arr_python_dict = pandas.Series(&#123;<span class="string">&quot;北京&quot;</span>:<span class="number">11</span>,<span class="string">&quot;上海&quot;</span>:<span class="number">12</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(arr_python_dict)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ol><li>series对象的表现形式为索引在左，值在右    </li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>    <span class="number">3</span></span><br><span class="line"><span class="number">1</span>    <span class="number">4</span></span><br><span class="line"><span class="number">2</span>    <span class="number">5</span></span><br><span class="line"><span class="number">3</span>    <span class="number">6</span></span><br><span class="line"><span class="number">4</span>    <span class="number">7</span></span><br><span class="line"><span class="number">5</span>    <span class="number">8</span></span><br><span class="line"><span class="number">6</span>    <span class="number">9</span></span><br><span class="line">dtype: int64</span><br><span class="line">北京    <span class="number">11</span></span><br><span class="line">上海    <span class="number">12</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><pre><code>    2. 对于没有指定索引的series对象，默认从0开始赋索引    3. series对象可以使用value和index获取数组表现形式和索引对象    4. 与numpy数组相比，series对象可以通过索引获取单一值，或者一组数组的值</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">obj_arr_py = pandas.Series([<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(obj_arr_py)</span><br><span class="line">arr_obj_value = obj_arr_py.values</span><br><span class="line"><span class="built_in">print</span>(arr_obj_value)</span><br><span class="line">arr_obj_index = obj_arr_py.index</span><br><span class="line"><span class="built_in">print</span>(arr_obj_index)</span><br><span class="line"><span class="comment"># 通过索引取值</span></span><br><span class="line">arr_index_value = obj_arr_py[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(arr_index_value)</span><br><span class="line"><span class="comment"># 通过索引该值</span></span><br><span class="line">arr_change_value = obj_arr_py[<span class="number">3</span>] = <span class="number">90</span></span><br><span class="line"><span class="built_in">print</span>(obj_arr_py)</span><br><span class="line"><span class="comment"># 根据索引取值</span></span><br><span class="line">arr_cahnge_index = obj_arr_py[[<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>]]</span><br><span class="line"><span class="built_in">print</span>(arr_cahnge_index)</span><br></pre></td></tr></table></figure><p><strong>series 的最重要的功能就是会自动对齐索引不一样的数据</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">obj2 = pandas.Series(&#123;<span class="string">&quot;Ohio&quot;</span>: <span class="number">35000</span>, <span class="string">&quot;Oregon&quot;</span>: <span class="number">16000</span>, <span class="string">&quot;Texas&quot;</span>: <span class="number">71000</span>, <span class="string">&quot;Utah&quot;</span>: <span class="number">5000</span>&#125;)</span><br><span class="line">obj3 = pandas.Series(&#123;<span class="string">&quot;California&quot;</span>: numpy.nan, <span class="string">&quot;Ohio&quot;</span>: <span class="number">35000</span>, <span class="string">&quot;Oregon&quot;</span>: <span class="number">16000</span>, <span class="string">&quot;Texas&quot;</span>: <span class="number">7100</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(obj2 + obj3)</span><br><span class="line"><span class="comment"># 运行结果</span></span><br><span class="line">California        NaN</span><br><span class="line">Ohio          <span class="number">70000.0</span></span><br><span class="line">Oregon        <span class="number">32000.0</span></span><br><span class="line">Texas         <span class="number">78100.0</span></span><br><span class="line">Utah              NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><blockquote><p>series对象本身和索引都有一个name属性</p><p>series的索引可以通过赋值的方式直接修改</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">obj3 = pandas.Series(&#123;<span class="string">&quot;California&quot;</span>: numpy.nan, <span class="string">&quot;Ohio&quot;</span>: <span class="number">35000</span>, <span class="string">&quot;Oregon&quot;</span>: <span class="number">16000</span>, <span class="string">&quot;Texas&quot;</span>: <span class="number">7100</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(obj2 + obj3)</span><br><span class="line">obj3.name = <span class="string">&#x27;population&#x27;</span></span><br><span class="line">obj3.index.name = <span class="string">&#x27;state&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(obj3)</span><br><span class="line"><span class="comment"># 运行结果</span></span><br><span class="line">state</span><br><span class="line">California        NaN</span><br><span class="line">Ohio          <span class="number">35000.0</span></span><br><span class="line">Oregon        <span class="number">16000.0</span></span><br><span class="line">Texas          <span class="number">7100.0</span></span><br><span class="line">Name: population, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num_obj = pandas.Series([<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">num_obj.index = [<span class="string">&quot;h&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;o&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(num_obj)</span><br><span class="line"><span class="comment"># 运行结果</span></span><br><span class="line">h    <span class="number">1</span></span><br><span class="line">l    <span class="number">4</span></span><br><span class="line">l    <span class="number">5</span></span><br><span class="line">o    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><h3 id="dataframe"><a href="#dataframe" class="headerlink" title="dataframe"></a>dataframe</h3><p>:::info</p><ul><li>dataframe 是一种表格性数据结构，含一组有序的列，每列可以是类型不同的值</li><li>dataframe 也有列索引，可以看做是由series组成的字典</li><li>与其他类似的数据结构来比（比如R语言中也有data.frame）。dataframe面向行和列的操作是基本平衡的</li><li>dataframe 的数据以一个或者多个二维块存放，而不是字典或者是列表这样的一维结构</li></ul><p>:::</p><h4 id="实例化dataframe对象"><a href="#实例化dataframe对象" class="headerlink" title="实例化dataframe对象"></a>实例化dataframe对象</h4><blockquote><p>实例化dataframe对象的方法很多，最常用的就是传入一个等长列表或者一个numpy数组</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr_data = &#123;<span class="string">&quot;state&quot;</span>:[<span class="string">&quot;Ohio&quot;</span>,<span class="string">&quot;Ohio&quot;</span>,<span class="string">&quot;Ohio&quot;</span>,<span class="string">&quot;Nevada&quot;</span>,<span class="string">&quot;Nevada&quot;</span>],<span class="string">&quot;year&quot;</span>:[<span class="number">2001</span>,<span class="number">2002</span>,<span class="number">2003</span>,<span class="number">2024</span>,<span class="number">2025</span>],<span class="string">&quot;population&quot;</span>:[<span class="number">1.3</span>,<span class="number">1.2</span>,<span class="number">1.4</span>,<span class="number">3.4</span>,<span class="number">2.8</span>]&#125;</span><br><span class="line"><span class="comment"># 传入一个数组</span></span><br><span class="line">arr_frame = pandas.DataFrame(arr_data)</span><br><span class="line"><span class="built_in">print</span>(arr_frame)</span><br></pre></td></tr></table></figure><blockquote><p>如果指定了顺序，dataframe就会按照指定顺序排列</p><p>如果传入的列在数据中找不到，就会产生NAN值</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">arr_frame_non = pandas.DataFrame(arr_data,columns=[<span class="string">&quot;year&quot;</span>,<span class="string">&quot;state&quot;</span>,<span class="string">&quot;population&quot;</span>,<span class="string">&quot;del&quot;</span>],index = [<span class="string">&quot;one&quot;</span>,<span class="string">&quot;tow&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(arr_frame_non)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果</span></span><br><span class="line">       year   state  population  <span class="keyword">del</span></span><br><span class="line">one    <span class="number">2001</span>    Ohio         <span class="number">1.3</span>  NaN</span><br><span class="line">tow    <span class="number">2002</span>    Ohio         <span class="number">1.2</span>  NaN</span><br><span class="line">three  <span class="number">2003</span>    Ohio         <span class="number">1.4</span>  NaN</span><br><span class="line">four   <span class="number">2024</span>  Nevada         <span class="number">3.4</span>  NaN</span><br><span class="line">five   <span class="number">2025</span>  Nevada         <span class="number">2.8</span>  NaN</span><br><span class="line">[Finished <span class="keyword">in</span> 830ms]</span><br></pre></td></tr></table></figure><blockquote><p>通过类似与字典标记的方式，可以将一个dataframe的列获取为一个series</p><p>返回的series拥有与原dataframe一样的索引，并设置了name属性值</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">arr_frame_state = arr_frame_non[<span class="string">&quot;state&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;adout state :\n&quot;</span>,arr_frame_state)</span><br><span class="line">arr_frame_population = arr_frame_non[<span class="string">&quot;population&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;adout the population: \n&quot;</span>,arr_frame_population)</span><br><span class="line"><span class="comment"># 运行结果</span></span><br><span class="line">adout state :</span><br><span class="line">one        Ohio</span><br><span class="line">tow        Ohio</span><br><span class="line">three      Ohio</span><br><span class="line">four     Nevada</span><br><span class="line">five     Nevada</span><br><span class="line">Name: state, dtype: <span class="built_in">object</span></span><br><span class="line">adout the population: </span><br><span class="line">one      <span class="number">1.3</span></span><br><span class="line">tow      <span class="number">1.2</span></span><br><span class="line">three    <span class="number">1.4</span></span><br><span class="line">four     <span class="number">3.4</span></span><br><span class="line">five     <span class="number">2.8</span></span><br><span class="line">Name: population, dtype: float64</span><br><span class="line">[Finished <span class="keyword">in</span> 839ms] </span><br></pre></td></tr></table></figure><p>dataframe可以通过对索引赋值的方式修改列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">arr_frame_non[<span class="string">&quot;del&quot;</span>] = <span class="number">15</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;new arr_frame_non:\n&quot;</span>,arr_frame_non)</span><br><span class="line">arr_frame_non[<span class="string">&quot;del&quot;</span>] = numpy.arange(<span class="number">3</span>,<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sencond new arr_frame_non\n&quot;</span>,arr_frame_non)</span><br></pre></td></tr></table></figure><p>将列表或者数组赋值给某一列时，长度应该相等</p><p>如果赋值的是series，就会精确匹配dataframe的索引，空缺部位会填上缺失值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val = pandas.Series([<span class="string">&quot;red&quot;</span>,<span class="string">&quot;black&quot;</span>,<span class="string">&quot;pink&quot;</span>],index=[<span class="string">&quot;tow&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span>])</span><br><span class="line">arr_frame_non[<span class="string">&quot;del&quot;</span>] = val</span><br><span class="line"><span class="built_in">print</span>(arr_frame_non)</span><br></pre></td></tr></table></figure><p>为不存在的列赋值会创建新的列</p><p>关键字del 可以用来删除列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">arr_frame_non[<span class="string">&quot;eastern&quot;</span>] = arr_frame_non.state == <span class="string">&quot;Ohio&quot;</span></span><br><span class="line"><span class="built_in">print</span>(arr_frame_non)</span><br><span class="line"><span class="keyword">del</span> arr_frame_non[<span class="string">&quot;del&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(arr_frame_non)</span><br><span class="line"><span class="built_in">print</span>(arr_frame_non.columns)</span><br><span class="line"><span class="comment"># 运行结果</span></span><br><span class="line">       year   state  population    <span class="keyword">del</span>  eastern</span><br><span class="line">one    <span class="number">2001</span>    Ohio         <span class="number">1.3</span>    NaN     <span class="literal">True</span></span><br><span class="line">tow    <span class="number">2002</span>    Ohio         <span class="number">1.2</span>    red     <span class="literal">True</span></span><br><span class="line">three  <span class="number">2003</span>    Ohio         <span class="number">1.4</span>    NaN     <span class="literal">True</span></span><br><span class="line">four   <span class="number">2024</span>  Nevada         <span class="number">3.4</span>  black    <span class="literal">False</span></span><br><span class="line">five   <span class="number">2025</span>  Nevada         <span class="number">2.8</span>   pink    <span class="literal">False</span></span><br><span class="line">       year   state  population  eastern</span><br><span class="line">one    <span class="number">2001</span>    Ohio         <span class="number">1.3</span>     <span class="literal">True</span></span><br><span class="line">tow    <span class="number">2002</span>    Ohio         <span class="number">1.2</span>     <span class="literal">True</span></span><br><span class="line">three  <span class="number">2003</span>    Ohio         <span class="number">1.4</span>     <span class="literal">True</span></span><br><span class="line">four   <span class="number">2024</span>  Nevada         <span class="number">3.4</span>    <span class="literal">False</span></span><br><span class="line">five   <span class="number">2025</span>  Nevada         <span class="number">2.8</span>    <span class="literal">False</span></span><br><span class="line">Index([<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;population&#x27;</span>, <span class="string">&#x27;eastern&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure><p>将一个嵌套字典传给dataframe，解释为：外层字典的键作为列，内层字典的键作为索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">population = &#123;<span class="string">&quot;Nevada&quot;</span>:&#123;<span class="number">2000</span>:<span class="number">1.4</span>,<span class="number">2002</span>:<span class="number">1.9</span>,<span class="number">2003</span>:<span class="number">2.0</span>&#125;,<span class="string">&quot;Ohio&quot;</span>:&#123;<span class="number">2000</span>:<span class="number">1.3</span>,<span class="number">2001</span>:<span class="number">1.5</span>,<span class="number">2002</span>:<span class="number">1.9</span>,<span class="number">2003</span>:<span class="number">1.8</span>&#125;&#125;</span><br><span class="line">arr_frame_population = pandas.DataFrame(population)</span><br><span class="line"><span class="built_in">print</span>(arr_frame_population)</span><br><span class="line"><span class="comment"># 运行结果</span></span><br><span class="line">      Nevada  Ohio</span><br><span class="line"><span class="number">2000</span>     <span class="number">1.4</span>   <span class="number">1.3</span></span><br><span class="line"><span class="number">2002</span>     <span class="number">1.9</span>   <span class="number">1.9</span></span><br><span class="line"><span class="number">2003</span>     <span class="number">2.0</span>   <span class="number">1.8</span></span><br><span class="line"><span class="number">2001</span>     NaN   <span class="number">1.5</span></span><br><span class="line">[Finished <span class="keyword">in</span> 852ms]</span><br><span class="line"><span class="comment"># 对 &#x27;外层字典的键作为列，内层字典的键作为索引&#x27; 转替</span></span><br><span class="line">new_arr = arr_frame_population.T</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;new_arr:\n&quot;</span>,new_arr)</span><br><span class="line"><span class="comment"># 运行结果</span></span><br><span class="line">         <span class="number">2000</span>  <span class="number">2002</span>  <span class="number">2003</span>  <span class="number">2001</span></span><br><span class="line">Nevada   <span class="number">1.4</span>   <span class="number">1.9</span>   <span class="number">2.0</span>   NaN</span><br><span class="line">Ohio     <span class="number">1.3</span>   <span class="number">1.9</span>   <span class="number">1.8</span>   <span class="number">1.5</span></span><br><span class="line">[Finished <span class="keyword">in</span> 900ms]</span><br></pre></td></tr></table></figure><p>如果设置了index 和 cloumns 的 name 属性，这些属性也会被展示出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">arr_frame_population.index.name = <span class="string">&#x27;year&#x27;</span></span><br><span class="line">arr_frame_population.columns.name = <span class="string">&quot;state&quot;</span></span><br><span class="line"><span class="built_in">print</span>(arr_frame_population)</span><br><span class="line"><span class="comment"># 运行结果</span></span><br><span class="line">state  Nevada  Ohio</span><br><span class="line">year               </span><br><span class="line"><span class="number">2000</span>      <span class="number">1.4</span>   <span class="number">1.3</span></span><br><span class="line"><span class="number">2002</span>      <span class="number">1.9</span>   <span class="number">1.9</span></span><br><span class="line"><span class="number">2003</span>      <span class="number">2.0</span>   <span class="number">1.8</span></span><br><span class="line"><span class="number">2001</span>      NaN   <span class="number">1.5</span></span><br><span class="line">[Finished <span class="keyword">in</span> <span class="number">1.0</span>s]</span><br></pre></td></tr></table></figure><p>和series一样，values属性会以一个二维ndarry形式的dataframe中的数据</p><p>如果dataframe中的数据不同，数组的数据类型就会选择能兼容所有数据的数据类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">arr_population_value = arr_frame_non.values</span><br><span class="line"><span class="built_in">print</span>(arr_population_value)</span><br><span class="line">arr_value = arr_frame_population.values</span><br><span class="line"><span class="built_in">print</span>(arr_value)</span><br><span class="line"><span class="comment"># 运行结果</span></span><br><span class="line">[[<span class="number">2001</span> <span class="string">&#x27;Ohio&#x27;</span> <span class="number">1.3</span> <span class="literal">True</span>]</span><br><span class="line"> [<span class="number">2002</span> <span class="string">&#x27;Ohio&#x27;</span> <span class="number">1.2</span> <span class="literal">True</span>]</span><br><span class="line"> [<span class="number">2003</span> <span class="string">&#x27;Ohio&#x27;</span> <span class="number">1.4</span> <span class="literal">True</span>]</span><br><span class="line"> [<span class="number">2024</span> <span class="string">&#x27;Nevada&#x27;</span> <span class="number">3.4</span> <span class="literal">False</span>]</span><br><span class="line"> [<span class="number">2025</span> <span class="string">&#x27;Nevada&#x27;</span> <span class="number">2.8</span> <span class="literal">False</span>]]</span><br><span class="line">[[<span class="number">1.4</span> <span class="number">1.3</span>]</span><br><span class="line"> [<span class="number">1.9</span> <span class="number">1.9</span>]</span><br><span class="line"> [<span class="number">2.</span>  <span class="number">1.8</span>]</span><br><span class="line"> [nan <span class="number">1.5</span>]]</span><br><span class="line">[Finished <span class="keyword">in</span> 869ms]</span><br></pre></td></tr></table></figure><p>pandas的索引对象负责管理轴标签和其他元数据（比如轴名称）</p><h2 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h2><blockquote><p>用于绘制二维图形，数据可视化</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># plt中文字体设置</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]  <span class="comment"># 使用黑体</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>  <span class="comment"># 解决负号显示问题</span></span><br></pre></td></tr></table></figure><p>在matplotlib绘制图表时经常有中文字符显示问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"></span><br><span class="line">matplotlib.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]  <span class="comment"># 指定默认字体</span></span><br><span class="line">matplotlib.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>  <span class="comment"># 解决保存图像时负号&#x27;-&#x27;显示为方块的问题</span></span><br></pre></td></tr></table></figure><p>通过matplotlib绘制x-y 折线图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot</span><br><span class="line"><span class="comment">#              x轴        y轴</span></span><br><span class="line">pyplot.plot([<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>])</span><br><span class="line"><span class="comment"># ylabel y轴 名称| xlabel x轴名称</span></span><br><span class="line">pyplot.ylabel(<span class="string">&quot;每个人的身高&quot;</span>)</span><br><span class="line"><span class="comment"># 你可以使用 axis([xmin, xmax, ymin, ymax]) 来设置 x 轴和 y 轴的最小和最大范围。</span></span><br><span class="line">pyplot.axis([-<span class="number">1</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">6</span>])</span><br><span class="line">pyplot.show()</span><br></pre></td></tr></table></figure><h4 id="plot方法"><a href="#plot方法" class="headerlink" title="plot方法"></a>plot方法</h4><p>plot的绘图区域</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyplot.subplot(nrows,ncols,plo_number)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42731236/1731822322292-61d6d158-b05c-433f-945a-a2a62b80aca9.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建窗口</span></span><br><span class="line">pyplot.figure()</span><br><span class="line">pyplot.plot(x,y)</span><br><span class="line">pyplot.figure(figsize = (<span class="number">7</span>,<span class="number">5</span>))</span><br><span class="line">pyplot.plot(x,y2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建窗口</span></span><br><span class="line">pyplot.figure()</span><br><span class="line">pyplot.plot(x,y,color = <span class="string">&quot;blue&quot;</span>,linewidth=<span class="string">&quot;1&quot;</span>)</span><br><span class="line">pyplot.plot(x,y2,color = <span class="string">&quot;pink&quot;</span>,linewidth= <span class="string">&quot;5&quot;</span>)</span><br><span class="line">pyplot.ylabel(<span class="string">&quot;y&quot;</span>,fontsize=<span class="number">20</span>)</span><br><span class="line">pyplot.xlabel(<span class="string">&quot;x&quot;</span>,fontsize=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">ad, = pyplot.plot(x,y,color = <span class="string">&quot;red&quot;</span>,linewidth=<span class="string">&quot;1&quot;</span>)</span><br><span class="line">se, = pyplot.plot(x,y2,color = <span class="string">&quot;yellow&quot;</span>,linewidth = <span class="string">&quot;6&quot;</span>)</span><br><span class="line"><span class="comment"># loc -》 自动选择图例最佳位置</span></span><br><span class="line">pyplot.legend(handles=[ad,se],labels=[<span class="string">&quot;ad&quot;</span>,<span class="string">&quot;se&quot;</span>],loc=<span class="string">&quot;best&quot;</span>)</span><br><span class="line">pyplot.ylabel(<span class="string">&quot;y&quot;</span>,color = <span class="string">&quot;red&quot;</span>)</span><br><span class="line">pyplot.xlabel(<span class="string">&quot;x&quot;</span>,color = <span class="string">&quot;gray&quot;</span>,fontsize = <span class="number">30</span>)</span><br><span class="line">pyplot.xlim((<span class="number">0</span>,<span class="number">1</span>)) <span class="comment"># 只截取一段进行显示</span></span><br><span class="line">pyplot.ylim((<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>点状图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 点状图</span></span><br><span class="line">dots1 = numpy.random.rand(<span class="number">50</span>)</span><br><span class="line">dots2 = numpy.random.rand(<span class="number">50</span>)</span><br><span class="line"><span class="comment">#c表示颜色，alpha表示透明度</span></span><br><span class="line">pyplot.scatter(dots1,dots2,c = <span class="string">&quot;pink&quot;</span>,alpha=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p>柱状图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 柱状图</span></span><br><span class="line">x = numpy.arange(<span class="number">4</span>)</span><br><span class="line">y = numpy.array([<span class="string">&quot;one&quot;</span>,<span class="string">&quot;tow&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>])</span><br><span class="line"><span class="comment"># facecolor : 柱状图填充颜色，edgecolor : 柱状图描边颜色</span></span><br><span class="line">pyplot.bar(y,x,facecolor = <span class="string">&quot;red&quot;</span>,edgecolor=<span class="string">&quot;black&quot;</span>)</span><br></pre></td></tr></table></figure><p>饼图绘制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 饼图绘制</span><br><span class="line">labels = <span class="string">&quot;forg&quot;</span>,<span class="string">&quot;dogs&quot;</span>,<span class="string">&quot;cats&quot;</span>,<span class="string">&quot;rabbits&quot;</span></span><br><span class="line">size = [<span class="number">15</span>,<span class="number">20</span>,<span class="number">35</span>,<span class="number">30</span>]</span><br><span class="line">explode = (<span class="number">0</span>,<span class="number">0.2</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">pyplot.pie(size,labels=labels,explode = explode)</span><br><span class="line">pyplot.axis(<span class="string">&#x27;equal&#x27;</span>)  <span class="comment"># 设置坐标轴比例相等</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="PIL"><a href="#PIL" class="headerlink" title="PIL"></a>PIL</h2><blockquote><p>处理图像</p></blockquote><h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"></span><br><span class="line">picture = Image.<span class="built_in">open</span>(<span class="string">&quot;tree.png&quot;</span>)</span><br><span class="line"><span class="comment"># 打开图片</span></span><br><span class="line"><span class="comment"># picture.show()</span></span><br><span class="line"><span class="comment"># plt.imshow(picture)</span></span><br><span class="line">img_mode = picture.mode</span><br><span class="line"><span class="built_in">print</span>(img_mode)</span><br><span class="line">img_weight,img_height = picture.size</span><br><span class="line"><span class="comment"># print(img_size)</span></span><br><span class="line"><span class="comment"># 旋转照片</span></span><br><span class="line">raotate = picture.rotate(<span class="number">90</span>)</span><br><span class="line"><span class="comment"># 裁剪图片</span></span><br><span class="line">crop_picture = picture.crop((<span class="number">0</span>,<span class="number">420</span>,<span class="number">690</span>,<span class="number">585</span>))</span><br><span class="line"><span class="comment"># 图片缩放</span></span><br><span class="line">resize_img = picture.resize((<span class="built_in">int</span>(img_weight * <span class="number">3</span>),<span class="built_in">int</span>(img_height * <span class="number">3</span>)), Image.LANCZOS)</span><br><span class="line">resize_img.save(<span class="string">&quot;resize.png&quot;</span>)</span><br><span class="line"><span class="comment"># resize_img.show()</span></span><br><span class="line"><span class="comment"># 镜像图片</span></span><br><span class="line">img_lr = resize_img.transpose(Image.FLIP_LEFT_RIGHT)</span><br><span class="line"><span class="comment"># img_lr.show()</span></span><br><span class="line"><span class="comment"># 上下翻转</span></span><br><span class="line">img_ud = resize_img.transpose(Image.FLIP_TOP_BOTTOM)</span><br><span class="line"><span class="comment"># img_ud.show()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.imshow(resize_img)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="计算机视觉识别"><a href="#计算机视觉识别" class="headerlink" title="计算机视觉识别"></a>计算机视觉识别</h2><p>增加机器学习的泛型</p><font style="color:transparent;">Matplotlib是一个主要用于绘制二维图形的</font><font style="color:transparent;">Python库</font><font style="color:transparent;">y是Python科学计算##库的基础。包含了</font><font style="color:transparent;">强大的N维数组对象和向量运算py是Python科学计算库的基础。包含了</font><font style="color:transparent;">强大的N维数组对象和向量运算ython科学计算库的基础。包含了</font>  <font style="color:transparent;">强大的N维数组对象和向量运算</font>   <font style="color:transparent;">Numpy是PythonNumpy是Python科学计算库的基础。包含了  </font><font style="color:transparent;">强大的N维数组对象和向量运算  </font><font style="color:transparent;"> 科学计算库的基础。包含了</font>  <font style="color:transparent;">强大的N维数组对象和向量运算</font>  ]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构入门</title>
      <link href="/2025/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/"/>
      <url>/2025/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>算法的重要性：？应对面试，算法面试 是面试的重头戏</p></blockquote><h1 id="算法和数据结构到底是神马东西？"><a href="#算法和数据结构到底是神马东西？" class="headerlink" title="算法和数据结构到底是神马东西？"></a>算法和数据结构到底是神马东西？</h1><h2 id="什么是算法？"><a href="#什么是算法？" class="headerlink" title="什么是算法？"></a>什么是算法？</h2><p>一组指令，用于完成特定的任务，或者解决问题</p><h2 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构?"></a>什么是数据结构?</h2><p><strong>结构</strong>：是各个组成部分相互搭配和排列的方式</p><p><strong>数据结构</strong>：是相互之间存在一种或多种特定关系的数据元素集合</p><p>按照视点不同：我们把数据结构分为<strong>逻辑结构和存储结构</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/42731236/1732261064005-b7163b77-f3bf-4624-b97e-a9cc1df52a0c.jpeg" alt="画板"></p><p>链式存储，需要用一个指针用来存放数据元素的地址，通过数据元素的地址寻找数据元素位置</p><p>逻辑结构面向问题，物理结构面向计算机</p><p>常见的数据结构：<font style="color:rgb(51, 51, 51);">数组、链表、栈、队列</font></p><h2 id="数据结构与算法的关系"><a href="#数据结构与算法的关系" class="headerlink" title="数据结构与算法的关系"></a><font style="color:rgb(51, 51, 51);">数据结构与算法的关系</font></h2><p>用一句著名的话总结</p><p><strong><font style="color:rgb(51, 51, 51);">著名的瑞士科学家N.Wirth教授提出：数据结构+算法＝程序。数据结构是程序的骨架，算法是程序的灵魂</font></strong></p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><blockquote><p>指执行当前代码消耗的时间，通常用O(order) 表示</p></blockquote><font style="color:rgb(51, 51, 51);">例如，如果有n个元素需要遍历，算法运算次数随着n的增大而增加，那么我们可以使用线性时间复杂度O(n)来描述它。如果算法具有平方级别的运算次数（这在很多情况下并不理想），我们会把它称为O(n²)时间复杂度。（此篇章我们不会涉及太多， 到时候面试的时候直接记住几个常用的即可）</font><h3 id="数据结构：什么是数组"><a href="#数据结构：什么是数组" class="headerlink" title="数据结构：什么是数组"></a><font style="color:rgb(51, 51, 51);">数据结构：什么是数组</font></h3><p>线性排列的一种结构</p><ol><li>有索引</li><li><strong><font style="color:rgb(51, 51, 51);">就是支持随机访问。这意味着我们可以在任何位置访问数组中的元素，而不需要按照特定的顺序逐一遍历。</font></strong></li></ol><font style="color:rgb(51, 51, 51);">如果想在任意位置上</font>**<font style="color:rgb(51, 51, 51);">添加或者删除数据</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">,就相当于来说会复杂一些 , 比如说现在添加一个Green添加到第2个位置上。</font><p> <img src="https://cdn.nlark.com/yuque/0/2024/png/42731236/1732262025348-30d38f91-b466-4ecb-864a-c75d63336098.png" alt=""></p><font style="color:rgb(51, 51, 51);">在数组的末尾确保需要增加的存储空间。为了给新数据腾出位置，要把已有数据一个个移开。首先把Red往后移。然后把Yellow往后移, 最后在空出来的位置上写入Green。添加数据的操作就完成了。</font><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42731236/1732262055471-65a7b2c4-d8c8-4bcc-adfa-98994922b056.png" alt=""></p><font style="color:rgb(51, 51, 51);">所以 , 虽然数组在访问时非常高效，但是插入和删除元素时会比较棘手，因为它需要对整个数组重新排序。但是，在需要快速访问元素时，数组仍被认为是一种非常有用的数据结构, 也就是数组</font>**<font style="color:rgb(51, 51, 51);">快速访问高效 , 插入删除低效</font>**:::info**<font style="color:rgb(51, 51, 51);">数组的时间复杂度</font>**<font style="color:rgb(51, 51, 51);">对数组操作所花费的运行时间。假设数组中有n个数据，由于访问数据时使用的是随机访问（通过下标可计算出内存地址），所以需要的运行时间仅为恒定的O（1）。</font><font style="color:rgb(51, 51, 51);">但另一方面，想要向数组中添加新数据时，必须把目标位置后面的数据一个个移开。所以，如果在数组头部添加数据，就需要O（n）的时间</font><p>:::</p><h3 id="数据结构：什么链表"><a href="#数据结构：什么链表" class="headerlink" title="数据结构：什么链表"></a>数据结构：什么链表</h3><font style="color:rgb(51, 51, 51);">链表是一种数据呈</font>**<font style="color:rgb(51, 51, 51);">线性排列</font>**<font style="color:rgb(51, 51, 51);">的数据结构</font><font style="color:rgb(51, 51, 51);">链表可以看作是一串火车车厢，车厢里存放了货物。每个车厢都有一个标记，标记着当前车厢的货物，并且还有一个指针，指向下一个车厢。这样，所有的车厢就通过指针构成了一条链，这就是链表</font><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42731236/1732262222037-41617c5b-e15b-434e-8e66-cf28fe498287.png" alt=""></p><font style="color:rgb(51, 51, 51);">因为数据都是分散存储的，所以如果想要访问数据，只能从第1个数据开始，顺着指针的指向一一往下访问（这便是顺序访问）。比如，想要找到Red这一数据，就得从Blue开始访问, 之后，还要经过Yellow，我们才能找Red。</font><font style="color:rgb(51, 51, 51);">如果想要添加数据，只需要改变添加位置前后的指针指向就可以，非常简单。比如，在Blue和Yellow之间添加Green。将Blue的指针指向的位置变成Green，然后再把Green的指针指向Yellow，数据的添加就大功告成了</font><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42731236/1732262255442-de9994ff-fdf1-4511-a5e0-36622c85bb02.png" alt=""></p><font style="color:rgb(51, 51, 51);">所以 , 尽管链表的插入和删除操作效率很高，但是访问链表中的元素时效率较低，</font>**<font style="color:rgb(51, 51, 51);">因为需要按序遍历整个链表寻找目标节点</font>**<font style="color:rgb(51, 51, 51);">。但在某些场景下，链表仍然是非常有用的数据结构。也就是说 </font>**<font style="color:rgb(51, 51, 51);">链表插入和删除高效, 快速访问低效</font>**:::info#### <font style="color:rgb(51, 51, 51);">关于链表的时间复杂度</font><font style="color:rgb(51, 51, 51);">我们把链表中的数据量记成n。访问数据时，我们需要从链表头部开始查找（线性查找），如果目标数据在链表最后的话，需要的时间就是O（n）。</font><font style="color:rgb(51, 51, 51);">添加数据只需要更改两个指针的指向，所以耗费的时间与n无关。如果已经到达了添加数据的位置，那么添加操作只需花费O（1）的时间。删除数据同样也只需O（1）的时间</font><p>:::</p><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a><font style="color:rgb(51, 51, 51);">栈和队列</font></h1><h2 id="什么是栈？"><a href="#什么是栈？" class="headerlink" title="什么是栈？"></a>什么是栈？</h2><font style="color:rgb(51, 51, 51);">栈也是一种数据呈线性排列的数据结构，不过在这种结构中，</font>**<font style="color:rgb(51, 51, 51);">我们只能访问最新添加的数据</font>**<font style="color:rgb(51, 51, 51);">。栈就像是一摞书，拿到新书时我们会把它放在书堆的最上面，取书时也只能从最上面的新书开始取</font><h3 id="出栈、入栈"><a href="#出栈、入栈" class="headerlink" title="出栈、入栈"></a><font style="color:rgb(51, 51, 51);">出栈、入栈</font></h3><font style="color:rgb(51, 51, 51);">往栈中添加数据的操作叫作"入栈"(push)。</font><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42731236/1732262510579-cc74dd24-83a0-4daa-a5cd-c6f723c5c764.png" alt=""></p><font style="color:rgb(51, 51, 51);">从栈中取出数据的操作叫作"出栈"( pop )</font><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42731236/1732262536027-b30c4a77-3f8a-427f-ad4f-34f9e4eca84c.png" alt=""></p><font style="color:rgb(51, 51, 51);">像栈这种最后添加的数据最先被取出，即“</font>**<font style="color:rgb(51, 51, 51);">后进先出”的结构</font>**<font style="color:rgb(51, 51, 51);">，我们称为Last In First Out，简称LIFO。与链表和数组一样，栈的数据也是线性排列，但在栈中，添加和删除数据的操作只能在一端进行，访问数据也只能访问到顶端的数据。想要访问中间的数据时，就必须通过出栈操作将目标数据移到栈顶才行</font><h2 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a><font style="color:rgb(51, 51, 51);">什么是队列</font></h2><font style="color:rgb(51, 51, 51);">与前面提到的数据结构相同，队列中的数据也呈线性排列。虽然与栈有些相似，但队列中添加和删除数据的操作分别是在两端进行的。就和“队列”这个名字一样，把它想象成排成一队的人更容易理解。在队列中，处理总是从第一名开始往后进行，而新来的人只能排在队尾。</font><h3 id="出队、入队"><a href="#出队、入队" class="headerlink" title="出队、入队"></a><font style="color:rgb(51, 51, 51);">出队、入队</font></h3><font style="color:rgb(51, 51, 51);">往队列中添加数据的操作叫作"入队"</font><p> <img src="https://cdn.nlark.com/yuque/0/2024/png/42731236/1732262638311-7b8f29f1-9b1f-46e5-bd66-5d7ecbcdac66.png" alt=""></p><font style="color:rgb(51, 51, 51);">从队列中删除数据的操作叫作"出队"</font><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42731236/1732262655651-f99596ea-bec6-492b-9f47-a8b9a0f5ca4f.png" alt=""></p><font style="color:rgb(51, 51, 51);">像队列这种最先进去的数据最先被取来，即“先进先出”的结构，我们称为First In First Out，简称FIFO</font><font style="color:rgb(51, 51, 51);">与栈类似，队列中可以操作数据的位置也有一定的限制。在栈中，数据的添加和删除都在同一端进行，而在队列中则分别是在两端进行的。队列也不能直接访问位于中间的数据，必须通过出队操作将目标数据变成首位后才能访问。“先来的数据先处理”是一种很常见的思路，所以队列的应用范围非常广泛.</font><font style="color:rgb(51, 51, 51);"></font><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a><font style="color:rgb(51, 51, 51);">哈希表</font></h1><font style="color:rgb(51, 51, 51);">哈希表存储的是由键（key）和值（value）组成的数据。例如，我们将每个人的性别作为数据进行存储，键为人名，值为对应的性别, 一般来说，我们可以把键当成数据的标识符，把值当成数据的内容</font><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42731236/1732263538942-1875cd58-549e-4268-8f06-af7ffb29ec50.png" alt=""></p><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><font style="color:rgb(51, 51, 51);">数据结构的</font>**<font style="color:rgb(51, 51, 51);">图存储结构</font>**<font style="color:rgb(51, 51, 51);">，常用于存储逻辑关系为 "</font>**<font style="color:rgb(51, 51, 51);">多对多</font>**<font style="color:rgb(51, 51, 51);">" 的数据。图存储结构，是</font>**<font style="color:rgb(51, 51, 51);">重点</font>**<font style="color:rgb(51, 51, 51);">，也是</font>**<font style="color:rgb(51, 51, 51);">难点</font>**<font style="color:rgb(51, 51, 51);">。</font><font style="color:rgb(51, 51, 51);">初学者要想玩转数据结构的图，就必须稳扎稳打，死抠图结构的每一个知识点，每一行代码，只有这样，才有彻底学会图存储结构的可能。  </font><font style="color:rgb(51, 51, 51);">除了讲解</font>**<font style="color:rgb(51, 51, 51);">图存储结构的理论知识</font>**<font style="color:rgb(51, 51, 51);">，本章还会穿插一些与图存储结构相关的常用算法，例如</font>**<font style="color:rgb(51, 51, 51);">克鲁斯卡尔算法</font>**<font style="color:rgb(51, 51, 51);">，</font>**<font style="color:rgb(51, 51, 51);">迪杰斯特拉算法</font>**<font style="color:rgb(51, 51, 51);">、</font>**<font style="color:rgb(51, 51, 51);">弗洛伊德算法</font>**<font style="color:rgb(51, 51, 51);">等。</font><h3 id="图存储结构"><a href="#图存储结构" class="headerlink" title="图存储结构"></a>图存储结构</h3><h4 id="什么是图？"><a href="#什么是图？" class="headerlink" title="什么是图？"></a>什么是图？</h4><p>多对多的逻辑存储结构</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42731236/1732608927241-28d874da-87a3-4f4d-ba09-e54236b3161a.png" alt="图1  无向图"></p><p>图中的各个元素被称为顶点（而不是节点）。在图存储结构中，习惯用Vi表示图中的顶点，所有顶点构成的集合用V表示</p><p>还有一种图的表示方式：</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42731236/1732609085755-3591cdee-d9c5-492b-80ec-3de9ae582859.png" alt="图2 有向图"></p><font style="color:rgb(51, 51, 51);">可以看到，各个顶点之间的关系并不是"双向"的。比如，V4 只与 V1 存在联系（从 V4 可直接找到 V1），而与 V3 没有直接联系；同样，V3 只与 V4 存在联系（从 V3 可直接找到 V4），而与 V1 没有直接联系，以此类推。</font>  <font style="color:rgb(51, 51, 51);"> 因此，图存储结构可细分两种表现类型，分别为</font>**<font style="color:rgb(51, 51, 51);">无向图</font>**<font style="color:rgb(51, 51, 51);">（图 1）和</font>**<font style="color:rgb(51, 51, 51);">有向图</font>**<font style="color:rgb(51, 51, 51);">（图 2）。</font><h4 id="图的存储结构-1"><a href="#图的存储结构-1" class="headerlink" title="图的存储结构"></a><font style="color:rgb(51, 51, 51);">图的存储结构</font></h4><ol><li><strong>弧头和弧尾</strong>：在有向图中，无箭头一段的端点被称为初始点或弧尾，<font style="color:rgb(51, 51, 51);">箭头直线的顶点被称为”</font><strong><font style="color:rgb(51, 51, 51);">终端点</font></strong><font style="color:rgb(51, 51, 51);">“或”</font><strong><font style="color:rgb(51, 51, 51);">弧头</font></strong><font style=“color:rgb(51, 51, 51);">"</font></li><li><strong>入度和出度</strong>：<font style="color:rgb(51, 51, 51);">对于有向图中的一个顶点 V 来说，箭头指向 V 的弧的数量为 V 的</font><strong><font style="color:rgb(51, 51, 51);">入度（InDegree，记为 ID(V)）</font></strong><font style="color:rgb(51, 51, 51);">；箭头远离 V 的弧的数量为 V 的</font><strong><font style="color:rgb(51, 51, 51);">出度（OutDegree，记为OD(V)）</font></strong><font style="color:rgb(51, 51, 51);">。拿图 2 中的顶点 V1来说，该顶点的入度为 1，出度为 2（该顶点的度为 3）</font></li><li><strong>（V1，V2）和<V1,V2>的区别</strong>：<font style="color:rgb(51, 51, 51);">无向图中描述两顶点（V1 和 V2）之间的关系可以用 (V1,V2) 来表示，而有向图中描述从 V1 到 V2 的”单向”关系用 <V1,V2> 来表示。由于图存储结构中顶点之间的关系是用线来表示的，因此 (V1,V2) 还可以用来表示无向图中连接 V1 和 V2 的线，又称为边；同样，<V1,V2> 也可用来表示有向图中从 V1 到 V2 带方向的线，又称为</font><strong><font style="color:rgb(51, 51, 51);">弧</font></strong></li><li><strong>集合VR的含义：</strong><font style="color:rgb(51, 51, 51);">并且，图中习惯用 VR 表示图中所有顶点之间关系的集合。例如，图 1 中无向图的集合 VR={(v1,v2),(v1,v4),(v1,v3),(v3,v4)}，图 2 中有向图的集合 VR={<v1,v2>,<v1,v3>,<v3,v4>,<v4,v1>}。</font></li><li><strong>路径和回路：</strong><font style="color:rgb(51, 51, 51);">无论是无向图还是有向图，从一个顶点到另一顶点途径的所有顶点组成的序列（包含这两个顶点），称为一条</font><strong><font style="color:rgb(51, 51, 51);">路径</font></strong><font style="color:rgb(51, 51, 51);">。如果路径中第一个顶点和最后一个顶点相同，则此路径称为</font><strong><font style="color:rgb(51, 51, 51);">“回路”（或”环”）</font></strong><font style="color:rgb(51, 51, 51);">。</font>  </li></ol><font style="color:rgb(51, 51, 51);"> 并且，若路径中各顶点都不重复，此路径又被称为"</font>**<font style="color:rgb(51, 51, 51);">简单路径</font>**<font style="color:rgb(51, 51, 51);">"；同样，若回路中的顶点互不重复，此回路被称为"</font>**<font style="color:rgb(51, 51, 51);">简单回路</font>**<font style="color:rgb(51, 51, 51);">"（或简单环）。</font>  <font style="color:rgb(51, 51, 51);"> 拿图 1 来说，从 V1 存在一条路径还可以回到 V1，此路径为 {V1,V3,V4,V1}，这是一个回路（环），而且还是一个简单回路（简单环）。</font>**在有向图中，每条路径或回路都是有方向的**6. **权和网的含义：**在某些实际场景中，图中的每条边（弧）会赋予一个数表示一定含义，这种与边（或弧）相匹配的实数被称为**权**，而带权的图被称为**网**![](https://cdn.nlark.com/yuque/0/2024/png/42731236/1732609941359-9b44bfea-6a4b-497e-b9ea-b2fb1d3776c8.png)、#### 图存储结构的分类根据不同的特征，图又可分为**完全图**，**连通图**，**稀疏图**和**稠密图**##### 完全图<font style="color:rgb(51, 51, 51);">若图中各个顶点都与除自身外的其他顶点有关系，这样的无向图称为完全图（如图 4a）。同时，满足此条件的有向图则称为</font>**<font style="color:rgb(51, 51, 51);">有向完全图</font>**<font style="color:rgb(51, 51, 51);">（图 4b)。</font><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42731236/1732610190807-9ac7bbaa-deb5-4e05-a68d-554369ec8182.png" alt="图4 完全图"></p><font style="color:rgb(51, 51, 51);">具有</font>**<font style="color:rgb(51, 51, 51);">n 个顶点的完全图</font>**<font style="color:rgb(51, 51, 51);">，图中边的数量为 n(n-1)/2；而对于具有 n 个顶点的有向完全图，图中弧的数量为 n(n-1)。</font><h5 id="稀疏图和稠密图"><a href="#稀疏图和稠密图" class="headerlink" title="稀疏图和稠密图"></a><font style="color:rgb(51, 51, 51);">稀疏图和稠密图</font></h5><font style="color:rgb(51, 51, 51);">这两种图是相对存在的，即如果图中具有很少的边（或弧），此图就称为"稀疏图"；反之，则称此图为"稠密图"。  </font>**<font style="color:rgb(51, 51, 51);"></font>**<font style="color:rgb(51, 51, 51);">稀疏和稠密的判断条件是：e<nlogn，其中 e 表示图中边（或弧）的数量，n 表示图中顶点的数量。如果式子成立，则为稀疏图；反之为稠密图。</font><h5 id="连通图："><a href="#连通图：" class="headerlink" title="连通图："></a><font style="color:rgb(51, 51, 51);">连通图：</font></h5><p>下面重点讲解</p><h2 id="什么是连通图"><a href="#什么是连通图" class="headerlink" title="什么是连通图"></a>什么是连通图</h2><h3 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h3><font style="color:rgb(51, 51, 51);">图中从一个顶点到达另一顶点，若存在至少一条路径，则称这两个顶点是连通着的。例如图 1 中，虽然 V1 和 V3 没有直接关联，但从 V1 到 V3 存在两条路径，分别是 </font>**<font style="color:rgb(51, 51, 51);">V1-V2-V3</font>**<font style="color:rgb(51, 51, 51);"> 和 </font>**<font style="color:rgb(51, 51, 51);">V1-V4-V3</font>**<font style="color:rgb(51, 51, 51);">，因此称 V1 和 V3 之间是连通的</font>![](https://cdn.nlark.com/yuque/0/2024/png/42731236/1732610624796-c4b011b6-a324-470f-95b5-efb76bda102a.png)<font style="color:rgb(51, 51, 51);">无向图中，如果任意两个顶点之间都能够连通，则称此无向图为</font>**<font style="color:rgb(51, 51, 51);">连通图</font>**<font style="color:rgb(51, 51, 51);">。例如，图 2 中的无向图就是一个连通图，因为此图中任意两顶点之间都是连通的。</font><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42731236/1732610662186-12ce2f99-fe3e-44d9-8915-ab807ab29c34.png" alt=""></p><p>若无向图不是连通图，但图中的某个子图满足连通图的性质，则称该子图为<strong>连通分量</strong></p><p><strong><font style="color:rgb(51, 51, 51);">前面讲过，由图中部分顶点和边构成的图为该图的一个子图，但这里的子图指的是图中”最大”的连通子图（也称”极大连通子图”）。</font></strong></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42731236/1732610828318-f3810746-d98e-4af7-bbdb-49923c09bf1a.png" alt=""></p><p><strong><font style="color:rgb(51, 51, 51);">图 3a) 中的无向图只能分解为 3 部分各自连通的”最大子图”。</font></strong></p><font style="color:rgb(51, 51, 51);">【连通分量的提出是以</font>**<font style="color:rgb(51, 51, 51);">"整个无向图不是连通图"</font>**<font style="color:rgb(51, 51, 51);">为前提的，因为如果无向图是连通图，则其无法分解出多个最大连通子图，因为图中所有的顶点之间都是连通的】</font><h3 id="强连通图"><a href="#强连通图" class="headerlink" title="强连通图"></a><font style="color:rgb(51, 51, 51);">强连通图</font></h3><font style="color:rgb(51, 51, 51);">有向图中，若任意两个顶点 Vi 和 Vj，满足从 Vi 到 Vj 以及从 Vj 到 Vi 都连通，</font>**<font style="color:rgb(51, 51, 51);">双向连通</font>**<font style="color:rgb(51, 51, 51);">，也就是都含有至少一条通路，则称此有向图为</font>**<font style="color:rgb(51, 51, 51);">强连通图</font>**<font style="color:rgb(51, 51, 51);">。如图 4 所示就是一个强连通图。</font><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42731236/1732611001600-b4783ed7-5b43-42d8-9382-6afd39f7c13d.png" alt="图4 强连通图"></p><font style="color:rgb(51, 51, 51);">若有向图本身不是强连通图，但其包含的最大连通子图具有强连通图的性质，则称该子图为</font>**<font style="color:rgb(51, 51, 51);">强连通分量</font>**![图5 强连通分量](https://cdn.nlark.com/yuque/0/2024/png/42731236/1732611023831-cb64586c-7472-41cb-8539-0fdc3d067462.png)<font style="color:rgb(51, 51, 51);">如图 5 所示，整个有向图虽不是强连通图，但其含有两个强连通分量。</font><font style="color:rgb(51, 51, 51);">可以这样说，连通图是在无向图的基础上对图中顶点之间的连通做了更高的要求，而强连通图是在有向图的基础上对图中顶点的连通做了更高的要求。</font><h2 id="什么是生成树"><a href="#什么是生成树" class="headerlink" title="什么是生成树"></a><font style="color:rgb(51, 51, 51);">什么是生成树</font></h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>什么是生成树？什么是是生成森林？</p><p><strong><font style="color:rgb(51, 51, 51);">对连通图进行遍历，过程中所经过的边和顶点的组合可看做是一棵普通树</font></strong><font style="color:rgb(51, 51, 51);">，通常称为</font><strong><font style="color:rgb(51, 51, 51);">生成树</font></strong><font style="color:rgb(51, 51, 51);">。</font></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42731236/1732611254728-5f443ff4-6ccc-4cce-b746-569755eb10c0.png" alt="图1 连通图及其对应的生成树"></p><font style="color:rgb(51, 51, 51);">如图 1 所示，图 1a) 是一张连通图，图 1b) 是其对应的 2 种生成树。</font><font style="color:rgb(51, 51, 51);">连通图中，由于任意两顶点之间可能含有多条通路，遍历连通图的方式有多种，往往一张连通图可能有多种不同的生成树与之对应</font><p>:::info</p><font style="color:rgb(51, 51, 51);">连通图的生成树必须满足以下2个条件：</font><ol><li>包含图中所有的顶点</li><li>任意两个顶点之间有且仅有一条通路</li></ol><p>:::</p><p>因此，连通图的生成树具有这样的特征，即生成树中<strong>边的数量 = 顶点数 - 1</strong>。</p><h3 id="生成森林"><a href="#生成森林" class="headerlink" title="生成森林"></a>生成森林</h3><p><strong>生成树是对应连通图来说的，而生成森林是对应非连通图来说的</strong>、</p><font style="color:rgb(51, 51, 51);">非连通图可分解为多个连通分量，而每个连通分量又各自对应多个生成树（至少是 1 棵），因此与整个非连通图相对应的，是由多棵生成树组成的生成森林</font><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42731236/1732611635285-012c2f92-1c81-4878-889a-f2a0640ebe26.png" alt="图2 非连通图和连通分量"></p><font style="color:rgb(51, 51, 51);">如图 2 所示，这是一张非连通图，可分解为 3 个连通分量，其中各个连通分量对应的生成树如图 3 所示：</font><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42731236/1732611726843-010e26bf-a316-420d-8fea-58315333a128.png" alt="图3 生成森林"></p><p>图三列出的仅是各个连通分量的一种生成树</p><font style="color:rgb(51, 51, 51);">因此，多个连通分量对应的多棵生成树就构成了整个非连通图的生成森林。</font><h2 id="图的顺序存储结构"><a href="#图的顺序存储结构" class="headerlink" title="图的顺序存储结构"></a><font style="color:rgb(51, 51, 51);">图的顺序存储结构</font></h2><h3 id="图的顺序存储"><a href="#图的顺序存储" class="headerlink" title="图的顺序存储"></a>图的顺序存储</h3><p>图结构能表示数据元素之间具有”多对多“关系。同样可以采用顺序存储，也就是数据存储图</p><p>:::info</p><font style="color:rgb(51, 51, 51);">存储图中各顶点本身数据，使用一维数组就足够了；存储顶点之间的关系时，要记录每个顶点和其它所有顶点之间的关系，所以需要使用二维数组。】</font><p><font style="color:rgb(51, 51, 51);">不同类型的图，存储的方式略有不同，根据图有无权，可以将图划分为两大类：</font><strong><font style="color:rgb(51, 51, 51);">图和网 </font></strong></p><p>:::</p><p><strong>图</strong>：有向图，无向图。</p><p><strong>网</strong>：带权的图</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电路</title>
      <link href="/2024/11/10/ele/"/>
      <url>/2024/11/10/ele/</url>
      
        <content type="html"><![CDATA[<h1 id="二进制的数据表达"><a href="#二进制的数据表达" class="headerlink" title="二进制的数据表达"></a>二进制的数据表达</h1><h2 id="二进制数据表达"><a href="#二进制数据表达" class="headerlink" title="二进制数据表达"></a>二进制数据表达</h2><h3 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h3><p>电报系统：编码，解码。两个过程，</p><h3 id="位的概念"><a href="#位的概念" class="headerlink" title="位的概念"></a>位的概念</h3><p>使用二进制进行编码，每当位数增加一位，不同取值的数量就会增加</p><p>如果：N = 位数</p><p>能产生的结果 = 2的N次方</p><p>计算机中将位数称为比特(bit)，计算机的最小数据单位</p><h3 id="早期的编码-摩尔斯电码"><a href="#早期的编码-摩尔斯电码" class="headerlink" title="早期的编码 摩尔斯电码"></a>早期的编码 摩尔斯电码</h3><p>降低成本，引入  <strong>时序</strong> 的概念</p><h3 id="ASCⅡ码"><a href="#ASCⅡ码" class="headerlink" title="ASCⅡ码"></a>ASCⅡ码</h3><p>7位，扩展了到8位</p><h2 id="二进制图片"><a href="#二进制图片" class="headerlink" title="二进制图片"></a>二进制图片</h2><h3 id="图片像素化"><a href="#图片像素化" class="headerlink" title="图片像素化"></a>图片像素化</h3><p>将图片拆分成色块</p><h3 id="像素数字化"><a href="#像素数字化" class="headerlink" title="像素数字化"></a>像素数字化</h3><p>三个字节表示色彩</p><p>位深为8</p><p>拓展到每个字节用三个字节表示，位深是32</p><h2 id="二进制表示声音"><a href="#二进制表示声音" class="headerlink" title="二进制表示声音"></a>二进制表示声音</h2><h3 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h3><p>将1s拆分成很多份，采样率越高，信息丢失越少</p><h3 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h3><p>每个采样率用一个数字表示高度，是一个连续量化离散的过程，与图片色深类似，取值与图片相似，叫做声音的位深。</p><h2 id="二进制存视频"><a href="#二进制存视频" class="headerlink" title="二进制存视频"></a>二进制存视频</h2><p>将图片，音频拼接起来</p><h2 id="与或非门"><a href="#与或非门" class="headerlink" title="与或非门"></a>与或非门</h2><p>输入 = 0/1</p><p>输出 = 1/0</p><h2 id="与门"><a href="#与门" class="headerlink" title="与门"></a>与门</h2><p>两个输入都为1，输出1</p><p>否则为0</p><p>Y = A * B</p><h2 id="或门"><a href="#或门" class="headerlink" title="或门"></a>或门</h2><p> 有一个输入为1，输出为1</p><p>Y = A + B </p><h2 id="非门"><a href="#非门" class="headerlink" title="非门"></a>非门</h2><p>Y = Ā</p><p>进1出0，进0出1</p><h2 id="异或门"><a href="#异或门" class="headerlink" title="异或门"></a>异或门</h2><p>比较两个信号，相同则为0，不同则为1</p><h2 id="与非门"><a href="#与非门" class="headerlink" title="与非门"></a>与非门</h2><p>先与，后非</p><p>全1出0，其他出1</p><h2 id="或非门"><a href="#或非门" class="headerlink" title="或非门"></a>或非门</h2><p>先或，后非</p><p>有1出0，全0出1</p><h2 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><p>半加器<img src="C:\Users\woo_w\AppData\Roaming\Typora\typora-user-images\image-20241006234547267.png" alt="image-20241006234547267"></p><p>1bit加法器</p><p><img src="C:\Users\woo_w\AppData\Roaming\Typora\typora-user-images\image-20241006235109132.png" alt="image-20241006235109132"></p><p>多位加法器</p><p><img src="C:\Users\woo_w\AppData\Roaming\Typora\typora-user-images\image-20241007020631938.png" alt="image-20241007020631938"></p><h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><p>半减器</p><p><img src="C:\Users\woo_w\AppData\Roaming\Typora\typora-user-images\image-20241007021234476.png" alt="半减器"></p><p>1bit减法器</p><p><img src="C:\Users\woo_w\AppData\Roaming\Typora\typora-user-images\image-20241007021627215.png" alt="全减器"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一颗星星</title>
      <link href="/2024/08/26/%E4%B8%80%E9%A2%97%E6%98%9F%E6%98%9F/"/>
      <url>/2024/08/26/%E4%B8%80%E9%A2%97%E6%98%9F%E6%98%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="太阳系小天体星空观察"><a href="#太阳系小天体星空观察" class="headerlink" title="太阳系小天体星空观察"></a><font style="color:#252525;">太阳系小天体星空观察</font></h1><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42731236/1737607011526-ab11b484-189d-41cf-87ec-b2ba9f1c776f.png" alt=""></p><p><em><font style="color:#252525;">©</font>__<font style="color:#252525;">Vito Technology, </font></em><font style="color:#252525;">Inc.663365491978644</font></p><font style="color:#252525;">距离C/2023 A3彗星（紫金山-阿特拉斯）在北半球天空呈现的精彩表演还有不到一个月的时间。它于2023年初被发现，被称为潜在的“本世纪最佳彗星”，很快，我们就会知道它是否真的如此！</font><h2 id="查找紫金山彗星在天空中的位置。"><a href="#查找紫金山彗星在天空中的位置。" class="headerlink" title="查找紫金山彗星在天空中的位置。"></a><font style="color:#252525;">查找紫金山彗星在天空中的位置。</font></h2><font style="color:#252525;">C/2023 A3（Tsuchinshan-ATLAS）彗星有何特别之处？如何在天空中找到C/2023 A3（Tsuchinshan-ATLAS）彗星？C/2023 A3（Tsuchinshan-ATLAS）彗星现在可见吗？C/2023 A3 彗星（紫金山-ATLAS）被摧毁了吗？C/2023 A3（Tsuchinshan-ATLAS）彗星在2024年能见度预测C/2023 A3彗星穿过太阳系的路径（2024年）观测C/2023 A3（Tsuchinshan-ATLAS）的最佳时间：它会变得多亮？</font><font style="color:#252525;">🤩</font><font style="color:#252525;">C/2023 A3（Tsuchinshan-ATLAS）会成为下一颗伟大彗星吗？彗星C/2023 A3 (Tsuchinshan-ATLAS) 的发现彗星C/2023 A3 (Tsuchinshan-ATLAS) 名称的含义紫金山彗星：总结“彗星就像猫：它们有尾巴，并且它们完全按照自己的意愿行事。”大卫·利维，《彗星：创造者与毁灭者》</font><font style="color:#252525;">C/2023 A3（Tsuchinshan-ATLAS）彗星有何特别之处？首先，彗星C/2023 A3（紫金山-ATLAS）可能非常明亮。这颗彗星的确切亮度是不可预测的，很大程度上取决于它在未来几个月的活动。然而，大多数消息来源都同意一件事：C/2023A3（紫金山-ATLAS）可能是肉眼可见的。如果运气好的话，它可能会变得异常明亮，甚至比2020年夏天令观测者高兴的彗星C/2020 F3（NEOWISE）还要亮。我们已经很久没有看到如此明亮的彗星了，因此观测者对C/2023 A3感到非常兴奋。这颗彗星预计也会有漂亮的尾巴。C/2023 A3在水星轨道内经过太阳后，其尘埃和冰彗发将变得非常热。冰会蒸发并逸入太空，并带走大量尘埃颗粒，这些尘埃颗粒会延伸成一条长而明亮的尾巴。历史表明，靠近太阳的彗星拥有最令人印象深刻的彗尾，这是彗星被太阳的热量烘烤后形成的。彗星C/2023 A3正是如此！</font><font style="color:#252525;">2007年的麦克诺彗星，展示着它美丽的大尾巴。</font><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42731236/1737607011753-daea8dc0-30fa-421e-bd7c-c06f84b864ab.png" alt=""></p><font style="color:#252525;">©</font><font style="color:#252525;">ESO/Sebastian Deiries</font><font style="color:#252525;">此外，从北半球可以完全看到C/2023 A3（紫金山-ATLAS）。从北半球可见的最后一颗明亮彗星是1997年的海尔-波普彗星。</font><h2 id="如何在天空中找到C-2023-A3（Tsuchinshan-ATLAS）彗星？"><a href="#如何在天空中找到C-2023-A3（Tsuchinshan-ATLAS）彗星？" class="headerlink" title="如何在天空中找到C/2023 A3（Tsuchinshan-ATLAS）彗星？"></a><font style="color:#252525;">如何在天空中找到C/2023 A3（Tsuchinshan-ATLAS）彗星？</font></h2><font style="color:#252525;">可以通过Sky Tonight看到C/2023 A3（紫金山-ATLAS）彗星。请打开应用程序，然后点击屏幕底部的放大镜图标。然后输入“C/2023 A3”并点击相应搜索结果旁边的目标图标。该应用程序将向您显示彗星的当前位置。将您的手机指向天空，然后按照白色箭头找到它。</font><font style="color:#252525;">C/2023 A3（Tsuchinshan-ATLAS）通过Sky Tonight应用程序。</font><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42731236/1737607011992-3f80e5ba-35ae-4c6e-b468-c2bc073f4b5a.png" alt=""></p><font style="color:#252525;">©</font><font style="color:#252525;">Vito Technology, Inc.</font><h2 id="C-2023-A3（Tsuchinshan-ATLAS）彗星现在可见吗？"><a href="#C-2023-A3（Tsuchinshan-ATLAS）彗星现在可见吗？" class="headerlink" title="C/2023 A3（Tsuchinshan-ATLAS）彗星现在可见吗？"></a><font style="color:#252525;">C/2023 A3（Tsuchinshan-ATLAS）彗星现在可见吗？</font></h2><font style="color:#252525;">在8月底和9月的大部分时间里，您将无法看到紫金山彗星，因为它在天空中距离太阳太近。但是，在9月的最后几天，彗星将远离太阳，变得可见。那时，它的亮度可能达到-1等，在南半球的早晨天空中可以看到得最清楚，与太阳的角距离为23°。</font><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42731236/1737607012441-b87d1d39-8e0b-4537-a599-50e23c8f880c.png" alt=""></p><font style="color:#252525;">©</font><font style="color:#252525;">Gerald Rhemann </font><h2 id="C-2023-A3-彗星（紫金山-ATLAS）被摧毁了吗？"><a href="#C-2023-A3-彗星（紫金山-ATLAS）被摧毁了吗？" class="headerlink" title="C/2023 A3 彗星（紫金山-ATLAS）被摧毁了吗？"></a><font style="color:#252525;">C/2023 A3 彗星（紫金山-ATLAS）被摧毁了吗？</font></h2><font style="color:#252525;">七月初，天文爱好者收到了一些坏消息。捷克裔美国天文学家、NASA彗星专家Zdenek Sekanina 在发表论文中表示，紫金山-ATLAS彗星的终结是不可避免的。他认为，这颗彗星正在出现碎裂的迹象，这主要表现在其亮度急剧停止增长，甚至亮度下降。但真的是这样吗？</font><font style="color:#252525;"> 回应Sekanina的文章其他天文学家发表了观点。他们注意到，Sekanina没有考虑彗星的相位角，即落在彗星上的光与从彗星反射到地球上的观察者的光之间的角度。</font><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42731236/1737607012621-2e0da19b-e33b-4b02-9477-6e0a2e029aed.png" alt=""></p><font style="color:#252525;">©</font><font style="color:#252525;">Vito Technology, Inc.</font><font style="color:#252525;">相位角对彗星的亮度有显着影响。当彗星与太阳相对时（与太阳的角距离为180°，与地球一致），相位角变得非常小，彗星表面的反射率急剧增加。</font><font style="color:#252525;">2024年4月中旬，这颗彗星冲向太阳，导致其亮度急剧增加。此外，被太阳风吹走的彗尾被投射到彗星“头部”后面，进一步增强了彗星的亮度。然后相位角开始增加，显着降低了彗差表面的反射率。此外，彗尾不再投射到彗星的“头部”上，因此并没有增加彗星的亮度。</font>![](https://cdn.nlark.com/yuque/0/2025/png/42731236/1737607012223-99d880d9-4442-4476-ac76-aeae0d61667e.png)<font style="color:#252525;">©</font><font style="color:#252525;">Vito Technology, Inc.</font><font style="color:#252525;">忽略这些因素可能会得出这样的结论：彗星亮度的急剧下降是由于彗核的破坏造成的。然而，事实并非如此。最新图像</font><font style="color:#252525;">，在Sekanina发表三周后拍摄，没有显示彗星毁灭的迹象</font><font style="color:#252525;">。相反，在1.5 AU的距离处。在远离太阳的地方，这颗彗星呈现出巨大的、发育良好的尘埃和气体尾部，以及一个巨大的绿色荧光彗发。目前该彗星的亮度估计为9.0星。引领这个亮度稍微超出了预测，表明它可能会变得比预期更亮。</font><font style="color:#252525;">为了确定彗星在经过太阳附近时被摧毁的概率，我们使用波特尔极限 （Bortle limit）</font><font style="color:#252525;">。彗星的绝对星等 (H) 必须比7 + 6 * q更亮（即数量必须小于），其中q是彗星到太阳的最小距离。如果H < 7 + 6 * q，彗星可能会在近日点幸存下来。</font><font style="color:#252525;">C/2023 A3的核心直径估计约为1-2公里（即H = 4.5），距太阳的最小距离为0.4天文单位。因此我们得到：4.5 < 7 + 6*0.4 = 9.4</font><font style="color:#252525;">我们可以看到，这个条件在很大程度上得到了满足，这表明彗星C/2023 A3（紫金山-ATLAS)不应该被摧毁。</font><font style="color:#252525;">C/2023 A3（Tsuchinshan-ATLAS）彗星在2024年能见度预测</font><font style="color:#252525;">以下是2024</font><font style="color:#252525;"> 每月能见度</font><font style="color:#252525;">的一些预测：9月：视星等为7-3，远离太阳并开始出现在南半球的早晨天空中。看到彗尾的好机会。从9月27日到10月2日，它出现在北半球的早晨天空中。从9月27日到10月2日，彗星在北半球</font><font style="color:#252525;">早晨出现在地平线上非常低的位置，然后消失几天，直到10月11日左右。10月：北半球观测彗星的最佳月份。10月12日彗星最接近地球时，彗星将达到最亮（亮度可能高达-3等）。它将位于傍晚天空地平线上方相对较高的位置。11月：4.5到8等，彗星在晚上可见。 彗星在北半球的升起高度将高于在南半球。日落后您便可看到它。12月：8到10等。彗星逐渐靠近天空中的太阳，升到地平线以下。从南半球看不到。请记住，彗星在星等3左右时可用肉眼看见。星等测量的是物体上分布的总光量，因此，对于恒星或行星等精确光源，肉眼可见度极限较低（星等6.5），而对于彗星或星系等弥散物体，肉眼可见度极限较高。</font><font style="color:#252525;">C/2023 A3（Tsuchinshan-ATLAS）彗星穿过天空的路径。</font><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42731236/1737607012867-75ea3d71-8402-4ff8-805b-571eebd855b7.png" alt=""></p><font style="color:#252525;">©</font><font style="color:#252525;">Vito Technology, Inc.</font><font style="color:#252525;">请注意彗星是非常难以预测的太空物体，数据（尤其是关于视星等的数据）会变化很快。但是，我们会尽力让您了解最新信息。C/2023 A3彗星穿过太阳系的路径（2024年）在这里，您可以获得2024年彗星穿越太阳系旅程的逐月指南。我们还制作了一个视频来可视化彗星在太空中的轨迹。观察它，看看彗星的亮度和位置如何随时间变化。</font><font style="color:#252525;">8月：C/2023 A3彗星将到达地球和火星之间的区域。到8月底，彗星距离地球将达到1.76个天文单位。</font><font style="color:#252525;">9月：C/2023 A3彗星将进入金星轨道。9月27日，这颗彗星将经过近日点，这意味着它将距离太阳最近，距离为0.39天文单位。在此期间，该彗星可能会在高温的冲击下分裂。</font><font style="color:#252525;">10月：如果C/2023 A3彗星在近日点幸存下来，那么在10月12日，它将距离地球最近，与地球的距离为0.48个天文单位。它将达到最大亮度并且即使用肉眼也可以观察到。</font><font style="color:#252525;">11月：C/2023 A3彗星将随着远离地球而逐渐失去亮度。到11月底，彗星与地球之间的距离将增加到1.94个天文单位。在接下来的20年中，这颗彗星将移向太阳系边缘，并且在接下来的26,000年内不会返回。</font><h2 id="观测C-2023-A3（Tsuchinshan-ATLAS）的最佳时间：它会变得多亮？🤩"><a href="#观测C-2023-A3（Tsuchinshan-ATLAS）的最佳时间：它会变得多亮？🤩" class="headerlink" title="观测C/2023 A3（Tsuchinshan-ATLAS）的最佳时间：它会变得多亮？🤩"></a><font style="color:#252525;">观测C/2023 A3（Tsuchinshan-ATLAS）的最佳时间：它会变得多亮？</font><font style="color:#252525;">🤩</font></h2><font style="color:#252525;">彗星C/2023 A3（Tsuchinshan-ATLAS）将在10月12日左右达到峰值亮度，届时它将以距离地球最近的距离（0.48天文单位）经过。很难预测彗星的确切亮度；大多数天文学家倾向于认为它的亮度足以用肉眼看到。10月9日至12日，由于前向散射的影响，C/2023 A3可能会增亮至-3.0等！相比之下，20世纪最著名的彗星之一海尔-波普彗星的峰值星等为-1.8。所谓的绿色彗星C/2022 E3（ZTF）在2023年初趋于活跃，其最大星等达到5.4等。著名彗星NEOWISE（C/2020 F3）的亮度为0.9等。</font><font style="color:#252525;">在接下来的几天里，彗星的可见尾巴将开始快速增长。 10月19日之后，当月亮离开夜空时，彗星的长尾巴可能会在黑暗的天空中可见。尾巴的长度将为20°：这大约是天空中满月大小的40倍！</font><font style="color:#252525;">最早可以在九月底开始在早晨的天空中寻找彗星。黎明前，它会在很低的天空中可见。 *9月27日彗星C/2023 A3（紫金山-ATLAS）将尽可能接近太阳（0.39天文单位）。最好的情况下，此时彗星将达到-1等；最坏的情况是亮度为4等，在非常黑暗的天空中肉眼几乎看不见。</font><font style="color:#252525;">经过近日点后，C/2023 A3（紫金山-ATLAS）将消失一段时间，并将于2024年10月上旬重新出现在夜空中。直到本月底，它仍将是晚间活动。然而，10月12日之后，这颗彗星将开始迅速消退，到月底将不再用肉眼看到。</font><h2 id="C-2023-A3（Tsuchinshan-ATLAS）会成为下一颗伟大彗星吗？"><a href="#C-2023-A3（Tsuchinshan-ATLAS）会成为下一颗伟大彗星吗？" class="headerlink" title="C/2023 A3（Tsuchinshan-ATLAS）会成为下一颗伟大彗星吗？"></a><font style="color:#252525;">C/2023 A3（Tsuchinshan-ATLAS）会成为下一颗伟大彗星吗？</font></h2><font style="color:#252525;">C/2023 A3（Tsuchinshan-ATLAS）很可能是下一个大彗星。尽管该术语没有官方定义，但大彗星通常异常明亮。事实上，大彗星是如此明亮，以至于即使不是有意寻找彗星的随意观察者也会注意到它。这样的彗星在天文学界之外也广为人知。1997年的海尔波普彗星和2007年的麦克诺特彗星是最后一颗被称为大彗星。彗星是非常难以预测的天体，总有惊喜的余地。目前，我们只能耐心等待C/2023 A3在2024年秋天的出现。</font><h2 id="彗星C-2023-A3-Tsuchinshan-ATLAS-的发现"><a href="#彗星C-2023-A3-Tsuchinshan-ATLAS-的发现" class="headerlink" title="彗星C/2023 A3 (Tsuchinshan-ATLAS) 的发现"></a><font style="color:#252525;">彗星C/2023 A3 (Tsuchinshan-ATLAS) 的发现</font></h2><font style="color:#252525;">2023年2月22日，位于南非的ATLAS望远镜探测到一个新的暗淡物体，然后它被证明是一颗彗星。它被暂时定名为A10SVYR。 这颗彗星也于2023年1月9日被紫金山天文台的望远镜独立发现。它由小行星中心被列入待确认天体名单，但在没有后续观测报告后，于1月被删除2023年30日，被认为迷失了。根据彗星命名系统，这颗彗星获得了两个天文台的名称，并被正式命名为C/2023 A3（Tsuchinshan-ATLAS）。发现后不久，截至2022年4月对这颗彗星的观测结果在小行星中心的档案中发现。C/2023 A3 (Tsuchinshan-ATLAS) 是一颗长周期彗星，绕太阳运行一周需要80,660年。</font><h2 id="彗星C-2023-A3-Tsuchinshan-ATLAS-名称的含义"><a href="#彗星C-2023-A3-Tsuchinshan-ATLAS-名称的含义" class="headerlink" title="彗星C/2023 A3 (Tsuchinshan-ATLAS) 名称的含义"></a><font style="color:#252525;">彗星C/2023 A3 (Tsuchinshan-ATLAS) 名称的含义</font></h2><font style="color:#252525;">根据国际天文学联合会（IAU）彗星命名系统，彗星的名称包含有关首次看到它的时间和地点的数据：字母C表示非周期彗星：此类彗星起源于奥尔特云，仅穿过太阳系一次或需要200至数千年绕太阳运行；“2023 A3”表示这颗彗星是在2023年1月上半月发现的（这对应于字母“A”），并且是同一时期发现的第三颗此类天体；“紫金山-阿特拉斯（Tsuchinshan-ATLAS）”是指这颗彗星是由紫金山天文台和小行星对地撞击预警系统（ATLAS）被发现的。</font><h2 id="紫金山彗星：总结"><a href="#紫金山彗星：总结" class="headerlink" title="紫金山彗星：总结"></a><font style="color:#252525;">紫金山彗星：总结</font></h2><font style="color:#252525;">很快，我们就会知道C/2023 A3 (紫金山-阿特拉斯) 彗星是否真的值得如此大肆宣传。2024年10月12日左右，它的亮度可能达到-3等，并成为过去100年北半球可见的最亮彗星之一！使用Sky Tonight应用程序在天空中找到紫金山彗星。该APP的“时间机器”功能将允许您在未来查看彗星在天空中的位置。</font><p><em><font style="color:#252525;">文本来源Vito Technology, Inc.</font></em></p><p><em><font style="color:#252525;">题目:太阳系小天体星空观察</font></em></p>]]></content>
      
      
      <categories>
          
          <category> 天文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 彗星 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
